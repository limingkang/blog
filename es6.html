<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Blog by limingkang</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <!-- <link rel="stylesheet" href="stylesheets/github-light.css"> -->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="前端开发记录">
    <meta name="keywords" content="gulp,react,node,webpack,redux,require,mysql,mongodb">
  </head>
  <body>
       <div class="big_container">
           <div class="title" style="margin-top:0;"><a href="http://es6.ruanyifeng.com/#docs/let">es6完整学习地址</a></div>
           <pre>
        1.使用let来声明一个块级作用域，使用const变量来声明一个常量

        2.顶层对象，在浏览器环境指的是window对象，在Node指的是global对象，顶层对象的属性与全局变量挂钩，被认为是JavaScript语
        言最大的设计败笔之一，ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层
        对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全
        局变量将逐步与顶层对象的属性脱钩

        3.变量的解构赋值
            let [x = 1, y = x] = [2];    // x=2; y=2
            var { foo: baz } = { foo: 'aaa', bar: 'bbb' };   baz // "aaa"
        这里一定要搞清楚谁是模式谁是变量以及对面全等于比较的时候才使用默认值

        4.ES6中允许使用反引号 ` 来创建字符串，此种方法创建的字符串里面可以包含由美元符号加花括号包裹的变量${vraible}
            let num = Math.random();
            console.log(`your num is ${num}`);

        5.Object.assign()是es6复制对象的方法是浅复制,只能复制到一层
            var o1 = { a: 1 };
            var o2 = { b: 2,d:{test:111,e:333} };
            var o3 = { c: 3 ,d:{test:2222}};
            var obj = Object.assign(o1, o2, o3);
            console.log(obj); // { a: 1, b: 2, c: 3,d:{test:222}}
            console.log(o1);  // { a: 1, b: 2, c: 3,d:{test:222}}   
            第一个对象是要最终输出的目标对象所以一般在前面写个空对象，相同属性会合并更新

        6.Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值而Object.keys方法
        返回的是键值，Object.entries方法返回一个数组,成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组
            var obj = { foo: 'bar', baz: 42 };
            Object.values(obj)  // ["bar", 42]
            Object.keys(obj)    // ["foo", "baz"]
            Object.entries(obj) // [ ["foo", "bar"], ["baz", 42] ]

        7.Object.create()可以用来创建一个新对象。新对象的原型就是调用 create 方法时传入的第一个参数

        8.扩展预算符(...)的使用
            let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
            x // 1
            y // 2
            z // { a: 3, b: 4 }

        9.ES5的对象属性名都是字符串，这容易造成属性名的冲突。为了防止属性名的冲突ES6引入了一种新的原始数据类型Symbol，表示独一无二的
        值。它是JavaScript语言的第七种数据类型
            var s1 = Symbol.for('foo');
            var s2 = Symbol.for('foo');
            s1 === s2 // true
            var s1 = Symbol();
            var s2 = Symbol();
            s1 === s2 // false
            var s1 = Symbol('foo');
            var s2 = Symbol('foo');
            s1 === s2 // false

        10.使用promise对象来解决异步问题,可以捕捉成功也可以捕捉失败抛出错误的时候的回调
            function timeout(ms) {
              return new Promise((resolve, reject) => {
                setTimeout(resolve, ms, 'done');
              });
            }
            timeout(100).then((value) => {
              console.log(value);
            });

        11.ES6中新增的箭头操作符 => 简化了函数的书写。操作符左边为输入的参数，而右边则是进行的操作以及返回的值，这样的写法可以为我们
        减少大量的代码，注意这会改变this指针的指向

        11.使用es6的generator函数来解决异步问题也可以内部调用yeild即可，对于该函数的封装的有co函数thunk函数等，注意还有一个
        async函数内部使用的是await也可以用来来解决异步问题

        12.es6也引入class的用法，其本质就是添加自身属性和原型对象上加属性也可以实现类的继承但是内部注意要去掉一个super()方法否则没办
        法用this。但是他没办法去定义私有属性和公有属性只能通过命名的规则或者函数二次嵌套调用勉强实现

        13.模块化开发要去了解import和export的用法和开发相应的规范
           </pre>

           <div class="title"><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001373962845513aefd77a99f4145f0a2c7a7ca057e7570000">git学习地址</a></div>
           <pre>
        git init                              初始化一个Git仓库

        git add "filename"                    添加改动文件到暂存区

        git commit -m "need change"           将暂存区的改动加到本地版本库

        git status                            表示工作区的状态，如果git status告诉你有文件被修改过，用git diff可以查看修改内容

        git log --pretty=oneline              也可不加参数就是比较多，这个命令可以查看提交历史，以便确定要回退到哪个版本  

        git reflog                            查看命令历史，以便确定要回到未来的哪个版本 

        git reset --hard HEAD~1               回到上一个版本也可以将HEAD~1改成相应版本id前几位，从而确定回到那个版本

        git checkout -- file                  直接丢弃工作区的修改,命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令
        这里有两种情况：
            一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；
            一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态

        git reset HEAD filename               直接丢弃暂存区的修改

        git rm filename                       用于删除一个文件,注意这个删除的修改已经提到暂存区了，之后直接git commit就行了

        git remote add origin git@github.com:limingkang/blog.git      关联远程库    

        git remote -v                         列出所有远程库地址

        git push origin "本地分支名字"        可以选择推送本地哪个分支进远程库

        git clone https://github.com/jquery/jquery.git                克隆远程库

        git branch                            查看分支

        git branch "branchname"               创建分支

        git checkout "branchname"             切换分支

        git checkout -b "branchname"          创建+切换分支

        git checkout -b [分支名] [远程名]/[分支名]
            从远程分支 checkout 出来的本地分支，称为_跟踪分支(tracking branch)_。跟踪分支是一种和远程分支有直接联系的本地分
            支。在跟踪分支里输入git push，Git 会自行推断应该向哪个服务器的哪个分支推送数据。反过来，在这些分支里运行
            git pull 会获取所有远程索引并把它们的数据都合并到本地分支中来。在克隆仓库时，Git 通常会自动创建一个名为 master
             的分支来跟踪 origin/master。这正是git push 和 git pull 一开始就能正常工作的原因。当然，你可以随心所欲地设定为
             其它跟踪分支，比如origin 上除了 master 之外的其它分支

        git merge "branchname"                合并某分支到当前分支

        git branch -d "branchname"            删除分支,没有被合并的无法删除

        git branch -D "branchname"            强制删除分支，不管其是否合并了

        git branch --set-upstream branch-name origin/branch-name   建立本地分支和远程分支的关联,这样才可以使用git pull

        git log --graph --pretty=oneline      git log --graph命令可以看到分支合并图

        git merge --no-ff -m "merge with no-ff" dev
            强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息
            因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去

        git stash                             当前工作现场“储藏”起来，等以后恢复现场后继续工作

        git stash list                        查看所有保存的工作现场

        git stash pop                         回到工作现场

        git tag "tagname" "commitid"          如果commitid没写的话，默认标签是打在最新提交的commit上的

        git tag                               查看所有标签

        git show "tagname"                    查看标签信息

        git push origin "tagname"             可以推送一个本地标签

        git push origin --tags                可以推送全部未推送过的本地标签

        git tag -d "tagname"                  可以删除一个本地标签

        git push origin :refs/tags/tagname    可以删除一个远程标签

        git config --global alias.co checkout 配置命令别名,若想删除某个别名,在仓库的Git配置文件.git/config文件中删除该行就行
           </pre>

           <div class="title">windows下面直接使用torrentgit更好用</div>
           <pre>
        1.先下载git安装之后，接着下载torrentgit
        2.ssh-keygen -t rsa -C "limk@mail.com" 最后得到了两个文件：id_rsa和id_rsa.pub
        3.id_rsa.pub打开这个拷贝到git公钥上面
        4.打开小乌龟的setting配置，点击git配置名字和email
        5.点击network配置ssh client 就是git安装时候下面git\usr\bin\ssh.exe文件指到即可，这个是用来连接github的

        注意你push或者pull的地址必须是ssh的否则不能成功，通过git remote -v如果地址是https开头的则重新配置地址才行
        git remote rm origin
        git remote add origin git@github.com:test/myblog.git这是ssh的地址
           </pre>
       </div>
  </body>
</html>
