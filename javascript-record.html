<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Blog by limingkang</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <!-- <link rel="stylesheet" href="stylesheets/github-light.css"> -->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="前端开发记录">
    <meta name="keywords" content="gulp,react,node,webpack,redux,require,mysql,mongodb">
  </head>
  <body>
       	<div class="big_container">
       		<div class="title" style="margin-top:0;">jquery对异步对象封装时候的调用方法</div>
   			<pre>
   				var dfd = $.Deferred(); 
   				var dfd2 = $.Deferred();
   				function fn1(d){
   				    setTimeout( function(){
   				       d.resolve('13');
   				    }, 300);
   				}
   				function fn2(d){
   				    setTimeout( function(){
   				      d.resolve('2');
   				    }, 200);
   				}
   				fn1(dfd);
   				fn2(dfd2);
   				$.when(dfd,dfd2).done(function(data1,data2){
   				   console.log(data1);
   				   console.log(data2);
   				   console.log(3);
   				}).fail(function(data1,data2){
   				   console.log(data1);
   				   console.log(data2);
   				   console.log(4);
   				});
   				console.log(10);         //10 13 2 3
   			</pre>
       		<div class="explain">先用jq构造一个deferred对象，这个对象就是对原生promise对象的封装，将其以参数的形式传进去之后，可以读状态resolve,reject,pendding状态，配合when来处理对个异步，之后就可以调用done方法了</div>
       		
            <div class="title">js相等==运算符的比较规则小结</div>
            <pre>
            如果x不是正常值（比如抛出一个错误），中断执行。
            如果y不是正常值，中断执行。
            如果Type(x)与Type(y)相同，执行严格相等运算x === y。
            如果x是null，y是undefined，返回true。
            如果x是undefined，y是null，返回true。
            如果Type(x)是数值，Type(y)是字符串，返回x == ToNumber(y)的结果。
            如果Type(x)是字符串，Type(y)是数值，返回ToNumber(x) == y的结果。
            如果Type(x)是布尔值，返回ToNumber(x) == y的结果。
            如果Type(y)是布尔值，返回x == ToNumber(y)的结果。
            如果Type(x)是字符串或数值或Symbol值，Type(y)是对象，返回x == ToPrimitive(y)的结果。
            如果Type(x)是对象，Type(y)是字符串或数值或Symbol值，返回ToPrimitive(x) == y的结果。
            上面都不满足返回false。

            {}==null  //false
            0==null   //false    
            </pre>
            <div class="explain">以后遇到比较的时候，就对着上面套，如果没有匹配的，就返回false就行了</div>

            <div class="title">js/jquery宽高的理解和应用</div>
            <pre>
            1.window对象是一种全局对象，而document是一个html文档对象，其实document对象只是window对象的一部分，例如：
                window.location.href===document.location.href=loaction.href 注意window对象是可以省略的
            documentElement和body的区别
                对于元素节点，nodeType=1
                对于属性节点，nodeType=2
                对于文本节点，nodeType=3
                对于注释元素，nodeType=8
                对于文档元素，nodeType=9
            其实documentElement对象是包括body对象的，存在document.documentElement.childNodes[2]==document.body

            2.与window相关的宽高理解：
                window.innerHeight            浏览器可视区域的高度
                window.innerWidth             浏览器可视区域的宽度
                window.outHeight              整个浏览器窗口的高度
                window.outWidth               整个浏览器窗口的宽度，一般情况下和innerWidth的宽度一样即使有滚动条也一样
                window.screen.height          整个电脑屏幕的高度
                window.screen.width           整个电脑屏幕的宽度
                window.screen.availHeight     整个电脑屏幕可视区域的高度就是去掉电脑上的上面或者线面的导航剩下的高度
                window.screen.availWidth      整个电脑屏幕可视区域的宽度就是去掉电脑上的左右导航剩下的宽度
                window.screenTop              浏览器距离屏幕上边顶的距离
                window.screenLeft             浏览器距离屏幕左边边顶的距离
            注意：innnerWidth,innerWidth,outHeight,outWidth不兼容ie9以下的浏览器，但是screen对象全部兼容而且其是不变的
            
            3.与document相关的宽高，clientHeight和clientWidth所有浏览器处理都一样
                clientHeight               元素padding上下值加上内容高度值之和减去滚动条的高度不用加上border的高度
                clientWidth                元素padding左右值加上内容宽度之和减去滚动条的宽度不用加上border宽度
                clientTop                  为border-top的宽度，如果没写就为0
                clientLeft                 为border-left的宽度，如果没写就为0
            可以使用document.body.clientWidth得body的宽度也可以使用任何一个节点点clientWidth来获取该节点的宽度,
            同样节点点clientTop也可访问该节点border-top的宽度
            当我们想获取可视区域高度：document.body.clientHeight||docuemnt.documentElement.clientHeight

            4.与document相关的宽高，offsetHeight和offsetWidth
                offsetHeight               元素padding上下值加上内容高度值之和的高度再加上border的高度不用管滚动条
                offsetWidth                元素padding左右值加上内容宽度之和再加上border宽度不用管滚动条
                offsetTop ：
                    如果他的父级元素中没有定位元素的话就是相当于父元素为body，在ie8,9,10以及chrome中为自己的margin-left加
                    父元素上下padding加父元素的宽度加父元素的margin-left，但是在firefox中是不要加上父元素的宽度的                
                offsetLeft                 同上offsetTop理解一样 
            这些属性可以使用document.body.offsetWidth访问也可以使用任何一个节点点offsetWidth来访问 

            5.document.body.scrollHeight和document.body.scrollWidth存在兼容性问题,这里只是针对谷歌浏览器
                以document.body.scrollHeight为例，如果给定宽高小于浏览器大小的话，那么值就是浏览器的可视区域的高度，如果大于的
                话值就是body的高度加上margin上下加上border上下值，如果给定宽高大于浏览器窗口而且内容大于给定宽高的话，那么值就
                是内容高度加上自己的上padding和上margin值 
            domElement.scrollWidth和domElement.scrollHeight是不同于document.body的：
                以任何一个节点的scrollWidth为例，没有滚动轴时候为clientWidth有滚动轴的时候为实际内容宽度加上左右padding值 

            6.scrollTop和scrollLeft,这是一个可读写的属性，指的是当元素其中的内容超出其宽高的时候，元素被卷起的高度和宽度，我们
            可以去设置节点的scrollTop和scrollLeft的值，判断页面有没有滚动到底部就用这个属性，还有style.width和style.height就是返回
            元素的样式中实际宽高

            7.event对象中的坐标的理解：
                clientX和clientY            相对于浏览器（可视区左上角0,0）的坐标
                screenX和screenY            相对于设备屏幕左上角（0,0）的坐标
                offsetX和offsetY            相对于事件源左上角（0,0）的坐标
                pageX和pageY            相对于整个网页左上角（0,0）的坐标，一般用在有滚动轴的时候
            可以先定义一个事件传入event对象，之后通过event.clientX这样的方法访问,上面的位置都是相对于鼠标指针点的位置来算距离的
            
            8.判断页面滑动到底部还是顶部：
                var clients=window.innerHeight||document.documentElement.cilentHeight||document.body.clientHeight
                var scrollTop=document.body.scrollTop;
                var wholeHeight=document.body.srcollHeight;
                if(clients+scrollTop>=wholeHeight){
                    console.log("到底部了");
                }
                if(scrolltop==0){
                    console.log("我到顶部了");
                }
            这是整个页面的判断的时候，如果要是用在某个div上面的时候就先获取div节点之后将上面的document.body换成那个节点
            就行了，获取这个div高度用domdiv.clientHeight就行，上面那个在chrome和firefox下好像有点问题所以最好还是用jquery
                var clients=$(window).height();
                var scrollTop=$(window).scrollTop();
                var wholeHeight=$(document).height();

            9.getBoundingClientRect()
            这个方法返回一个矩形对象，包含四个属性：left、top、right和bottom。分别表示元素各边与页面上边和左边的距离。
            var box=document.getElementById('box');         // 获取元素
            alert(box.getBoundingClientRect().top);         // 元素上边距离页面上边的距离
            alert(box.getBoundingClientRect().right);       // 元素右边距离页面左边的距离
            alert(box.getBoundingClientRect().bottom);      // 元素下边距离页面上边的距离
            alert(box.getBoundingClientRect().left);        // 元素左边距离页面左边的距离
            注意：IE、Firefox3+、Opera9.5、Chrome、Safari支持，在IE中，默认坐标从(2,2)开始计算，导致最终距离比其他浏览器多出两
            个像素，我们需要做个兼容

            9.jquery中的宽高以及和宽高相关的方法，这里以宽举例，高和宽一样：
                .width()                    返回元素宽不包含padding,margin,border
                .innerWidth()               返回元素宽包含padding
                .outerWidth()               返回元素宽包含padding,border默认不包含margin
                .outerWidth("true")         返回元素宽包含padding,border,margin
                .scrollTop()  .scrollLeft() 这两个方法的返回值和上面的js下面的一样
                .offset()                   返回left和top两个值，相对于body内层border边的
                .position()                 返回left和top两个值，相对于父级定位元素的内层border边的
            $(window).height()              窗口可视区域高度
            $(document).height()            文档的高度
            对于window和document对象来说他们的height,innerHeight,outerHeight是一样的width同理，而其他节点对象是按上面那个规则的
             </pre>
            <div class="explain"></div>

            <div class="title">js判断浏览器方法以及监听横竖屏</div>
            <pre>
                var browser = {
                    versions: function () {
                        var u = navigator.userAgent, app = navigator.appVersion;
                        return {         //移动终端浏览器版本信息
                            trident: u.indexOf('Trident') > -1, //IE内核
                            presto: u.indexOf('Presto') > -1, //opera内核
                            webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
                            gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
                            mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
                            ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
                            android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或uc浏览器
                            iPhone: u.indexOf('iPhone') > -1, //是否为iPhone或者QQHD浏览器
                            iPad: u.indexOf('iPad') > -1, //是否iPad
                            webApp: u.indexOf('Safari') == -1 //是否web应该程序，没有头部与底部
                        };
                    }(),
                    language: (navigator.browserLanguage || navigator.language).toLowerCase()
                }
                if (browser.versions.mobile) {//判断是否是移动设备打开。browser代码在下面
                        var ua = navigator.userAgent.toLowerCase();//获取判断用的对象
                        if (ua.match(/MicroMessenger/i) == "micromessenger") {
                                //在微信中打开
                        }
                        if (ua.match(/WeiBo/i) == "weibo") {
                                //在新浪微博客户端打开
                        }
                        if (ua.match(/QQ/i) == "qq") {
                                //在QQ空间打开
                        }
                        if (browser.versions.ios) {
                                //是否在IOS浏览器打开
                        } 
                        if(browser.versions.android){
                                //是否在安卓浏览器打开
                        }
                } else {
                        //否则就是PC浏览器打开
                }

                监听横屏竖屏状态：                
                    window.addEventListener("orientationonchange",function(){})
                    window.orientation为0则它是纵向的，横向的则是90或者-90
                    但是这个事件不是所有的android设备都可以触发，可以加一个window.addEventListener("resize",function(){})
            </pre>

            <div class="title">jq中extend方法的复制以及NAN的奇怪现象</div>
            <pre>
                var obj1 = {
                  'a': 's1',
                  'b': [1,2,3,{'a':'s2'}],
                  'c': {'a':'s3', 'b': [4,5,6]}
                }
                var obj2 = $.extend(true, {}, obj1);   //深拷贝与浅拷贝
                obj2.a='s1s1';
                obj2.b[0]=100;
                obj2.c.b[0]=400;
                console.log(obj1);
                console.log(obj2);

                alert(typeof NaN); //弹出 'Number'
                alert(NaN === NaN); //为 false
            </pre>
            <div class="explain">通过true或者false来判断，默认false,jq的深复制(一层一层往下复制直到最底层)和浅复制(只复制顶层的基本类型元素)。所以对象中a肯定会被复制</div>

            <div class="explain">表单提交按钮类型全部改成submit类型啦,只要表单绑定submit事件，prevent默认提交，于是，既能回车响应，又能验证或者ajax或是原始提交处理</div>

            <div class="title">连接地址显示你链接的那个网站的图标</div>
            <pre>
            element.style.backgroundImage = "url(http://www.google.com/s2/u/0/favicons?domain="+ element.hostname +")";
            element.style.backgroundImage = "url(http://g.etfv.co/"+ element.href +")";
            第一个使用的是谷歌的api不过后一个好像更好用些，实例：
            <textarea style="width:90%;">
        	<img src="http://www.google.com/s2/u/0/favicons?domain=www.zhangxinxu.com" />
        	<img src="http://g.etfv.co/http://www.zhangxinxu.com/wordpress/?p=2445" />
            </textarea>
            </pre>

            <div class="title">全屏效果JavaScript实现</div>
            <pre>
                 全屏效果click, mousedwon, mouseup事件才能触发
                 全屏方法为：全屏元素.requestFullScreen(); 目前不同的浏览器需要不同的前缀，如mozRequestFullScreen或webkitRequestFullScreen
                 取消全屏为：全屏元素.cancelFullScreen(); 同样，不同浏览器需要添加私有前缀，如mozCancelFullScreen或webkitCancelFullScreen.
                 可以通过document.fullScreen判断浏览器是否处于全屏状态。注意：FireFox和Chrome写法上有不同，Webkit内核浏览器需要增加个is, 如document.webkitIsFullScreen; 而Firefox则是document.mozFullScreen.
                 :full-screen{}用在CSS代码中，可以控制全屏元素（及其子元素）全屏状态时的样式。同样，不同浏览器不同前缀。如:-moz-full-screen{}或:- webkit-full-screen{}.
                 一个页面如果有多个全屏元素，在CSS控制的时候，可以使用类似#element:full-screen{}的选择器分别控制。
            </pre>

            <div class="title">关于存储方式的小结</div>
            <pre>
                1.http缓存也就是cookies的应用
                2.web storage网络存储就是讲localstorage sessionstorage
                    网络存储为每个域提供5MB简单的键值形式的存储空间，在ios上网络存储可以存储utf-16格式的字符串文本，这就意味着每个字符需要两倍多的字节，所以在
                    ios上存储的实际上是2.5MB,从localStorage获取数据比内存中慢得多，还不包括对json字符串的解码增加的成本(localStorage只能存储字符串,而且它最终的值也是存储在本地内存)
            	3.application storage就是应用缓存，也就是h5的离线缓存,在html标签中写上manifest="clock.manifest"，
            	并在同级目录下面建立clock.manifest文件，理论上随便什么后缀名都可以，但是一般写manifest
            		下面说明书写 cache manifest 文件需要遵循的格式。
            		      首行必须是 CACHE MANIFEST。
            		      其后，每一行列出一个需要缓存的资源文件名。
            		      可根据需要列出在线访问的白名单。白名单中的所有资源不会被缓存，在使用时将直接在线访问。声明白名单使用 NETWORK：标识符。
            		      如果在白名单后还要补充需要缓存的资源，可以使用 CACHE：标识符。
            		      如果要声明某 URI 不能访问时的替补 URI，可以使用 FALLBACK：标识符。其后的每一行包含两个 URI，当第一个 URI 
            		      不可访问时，浏览器将尝试使用第二个 URI。
            		      注释要另起一行，以 # 号开头。
            		示例：
            		      CACHE MANIFEST 
            		       # 上一行是必须书写的。

            		      CACHE: 
            		      style/default.css 

            		      FALLBACK: 
            		      /files/projects /projects 

            		      NETWORK: 
            		      comm.cgi
            		文件的更新是它最大的难点，也是现在慎重使用的原因
            		自动更新 
            		    浏览器除了在第一次访问 Web 应用时缓存资源外，只会在 cache manifest 文件本身发生变化时更新缓存。而 cache manifest 
            		    中的资源文件发生变化并不会触发更新。
            		手动更新 
            		    开发者也可以使用 window.applicationCache 的接口更新缓存。方法是检测 window.applicationCache.status 
            		    的值，如果是 UPDATEREADY，那么可以调用 window.applicationCache.update() 
            		    更新缓存。示范代码如下：
            		             if (window.applicationCache.status == window.applicationCache.UPDATEREADY) 
            		            ｛
            		             window.applicationCache.update(); 
            		            ｝
            		navigator.onLine 属性表示当前是否在线。如果为 true, 表示在线；如果为 false, 
            		表示离线。当网络状态发生变化时，navigator.onLine 的值也随之变化。开发者可以通过读取它的值获取网络状态。
            		online/offline 事件 
            		当开发离线应用时，通过 navigator.onLine 获取网络状态通常是不够的。开发者还需要在网络状态发生变化时立刻得到通知，因此 HTML5 
            		还提供了 online/offline 事件。当在线 / 离线状态切换时，online/offline 事件将触发在 body 元素上，并且沿着 
            		document.body、document 和 window 的顺序冒泡。因此，开发者可以通过监听它们的 online/offline 事件来获悉网络状态。
            	4.Web SQL Database可以我完成复杂的关心型数据存储，就是通过建立本地内存中的一个数据库 
				    先介绍三个核心方法
				        1、openDatabase：这个方法使用现有数据库或创建新数据库创建数据库对象。
				        2、transaction：这个方法允许我们根据情况控制事务提交或回滚。
				        3、executeSql：这个方法用于执行真实的SQL查询。
            </pre>
            <div class="explain">IndexedDB是HTML5-WebStorage的重要一环，是一种轻量级NOSQL数据库</div>

            <div class="title">手动实现观察者模式</div>
            <pre>
                var Observer = (function(slice) {
                    //订阅函数，可以传入多个任务名，会将其做为events的键相应值为一个数组里面放的是对应任务函数
                    function bind(event, fn) {
                        var events = this.events = this.events || {},
                            parts = event.split(/\s+/),
                            i = 0,
                            num = parts.length,
                            part;
                        //如果事件已经注册并且有对应函数事件则返回
                        if (events[event] && events[event].length) return this;
                        //注册事件，一个任务名只能对应一个任务函数
                        for (; i < num; i++) {
                            events[(part = parts[i])] = events[part] || [];
                            events[part].push(fn);
                        }
                        return this;
                    }
                    //只订阅一次
                    function one(event, fn) {
                        this.bind(event, function fnc() {
                            fn.apply(this, slice.call(arguments));
                            this.unbind(event, fnc);
                        });
                        return this;
                    }
                    //清空不需要的events中的事件
                    function unbind(event, fn) {
                        var events = this.events,
                            eventName, i, parts, num;
                        if (!events) return;
                        parts = event.split(/\s+/);
                        for (i = 0, num = parts.length; i < num; i++) {
                            if ((eventName = parts[i]) in events !== false) {
                                events[eventName].splice(events[eventName].indexOf(fn), 1);
                                if (!events[eventName].length) { //修正没有事件直接删除空数组
                                    delete events[eventName];
                                }
                            }
                        }
                        return this;
                    }
                    //触发函数
                    function trigger(event) {
                        var events = this.events,
                            i, args, falg;
                        //如果没有传入事件名或者事件并没有注册则返回
                        if (!events || event in events === false) return;
                        //第一个参数是事件名，以后的参数是要传入给该事件的参数，所以截取形参的第一个参数的后面的
                        args = slice.call(arguments, 1);
                        for (i = events[event].length - 1; i >= 0; i--) {
                            falg = events[event][i].apply(this, args);
                        }
                        return falg; //修正带返回
                    }
                    //返回实际要调用的函数
                    return function() {
                        this.on =
                            this.subscribe = bind;
                        this.off =
                            this.unsubscribe = unbind;
                        this.trigger =
                            this.publish = trigger;
                        this.one = one;
                        return this;
                    };
                    
                })([].slice);

                创建一个观察者对象
                var observer = new Observer();
                通过调用subscribe方法，实现一个事件的观察
                observer.subscribe("任务名"，处理函数)
                通过publish触发观察事件，在任意时刻触发了这个观察的任务名，将会触发这个事件订阅subscribe方法
                observer.publish("任务名")
                取消事件订阅，意味着就不会执行了
                 observer.unsubscribe("任务名")
            </pre>

            <div class="title">无刷新改变url，还点击前进后退按钮，ajax只能改变页面内容，这里就得加上pushState,简称pjax</div>
            <pre>
                 1、存储当前历史记录点
                 存储的方式类似于数组的入栈（Array.push()），在window.history里新增一个历史记录点，例如：

                 // 当前的url为：http://www.qingdou.me/index.html
                 var json={time:new Date().getTime()};
                 // @状态对象：记录历史记录点的额外对象，可以为空
                 // @页面标题：目前所有浏览器都不支持
                 // @可选的url：浏览器不会检查url是否存在，只改变url，url必须同域，不能跨域
                 window.history.pushState(json,"","http://www.qingdou.me/post-1.html");
                 var statemy = {
                         title: title,
                         url: options.url,
                         otherkey: othervalue
                 };
                 window.history.pushState(statemy, document.title, url);
                 执行了pushState方法后，页面的url地址为http://www.qingdou.me/post-1.html

                 2、替换当前历史记录点
                 window.history.replaceState和window.history.pushState类似，不同处在于replaceState不会在window.history里新增
                 历史记录点，其效果类似于window.location.replace(url)，都是不会在历史记录点里新增一个记录点的。当你为了响应用户的
                 某些操作而要更新当前历史记录条目的状态对象或URL时，使用replaceState()方法会特别合适。

                 3、监听历史记录点
                 监听历史记录点，可认为是监听URL的变化，但会忽略URL的hash部分，监听URL的hash部分，HTML5有新的API为onhashchange，
                 我的博客里也有说到该方法和跨浏览器的兼容解决方案。可以通过window.onpopstate来监听url的变化，并且可以获取存储在该历史
                 记录点的状态对象，也就是上文说到的json对象，如：

                 // 当前的url为：http://www.qingdou.me/post-1.html
                 window.onpopstate=function()
                 {
                 // 获得存储在该历史记录点的json对象
                 var json=window.history.state;
                 // 点击一次回退到：http://www.qingdou.me/index.html
                 // 获得的json为null
                 // 再点击一次前进到：http://www.qingdou.me/post-1.html
                 // 获得json为{time:1369647895656}
                 }
            </pre>
            <div class="explain">值得注意的是：javascript脚本执行window.history.pushState和window.history.replaceState不会触发onpopstate事件
                 以上再配合ajax就可做到完美,传统锚点无法实现前后键的一个跳转</div>

            <div class="title">自定义一个事件，例如人工合成tap事件</div>
            <pre>
                function foo(){
                    console.log("foo2 is execute");
                }
                var ev=document.createEvent('HTMLEvents');
                ev.initEvent('fakeEvent',false,false);
                document.addEventListener("fakeEvent",foo,false);  //节点也可以绑定该事件
                在标准浏览器里的console里执行 document.dispatchEvent(ev); 就可以看到console里显示出来了foo2 is execute
                createEvent()方法返回新创建的Event对象，支持一个参数，表示事件类型，具体见下表：
                参数          事件接口      初始化方法
                HTMLEvents    HTMLEvent     initEvent()
                MouseEvents   MouseEvent    initMouseEvent()
                UIEvents      UIEvent       initUIEvent()
                initEvent()方法用于初始化通过DocumentEvent接口创建的Event的值。支持三个参数：initEvent(eventName, canBubble, preventDefault). 
                分别表示事件名称，是否可以冒泡，是否阻止事件的默认操作。
            </pre>
            <div class="explain">先自定义tap事件然后触发他，在tap事件当中先绑定touchstart,touchend事件，判断事件间隔之后给个回调就行</div>

            <div class="title">对于transform使用matrix矩阵2D详解</div>
            <pre>
                 首先单位矩阵是这样的,也就是你不写的时候的样子：
                        -webkit-transform:matrix(1,0,0,1,0,0);
                        transform:matrix(1,0,0,1,0,0);
                 例如：向右移动10像素向下移动20像素可以这样写：
                         -webkit-transform:matrix(1,0,0,1,10,20);
                        transform:matrix(1,0,0,1,10,20);
                 例如：横纵扩2倍可以这样写：
                         -webkit-transform:matrix(2,0,0,2,0,0);
                        transform:matrix(2,0,0,2,0,0);
                 对于旋转scale和扭曲skew则该中间那两个0第一个表示x轴方向第二个表示y轴方向，而且他们在改动的时候，
                 还要根据三角函数算出第一个和第四个参数的值，因为页面呈现是大小会改动
            </pre>
            <div class="explain">当使用3d做gpu渲染的时候，并不能触发重绘，他只能使元素变大小或者旋转等，不能改颜色</div>

            <div class="title">触摸对象</div>
            <pre>
                每个触摸事件被触发后，会生成一个event对象，event对象里额外包括以下三个触摸列表
                touches:     //当前屏幕上所有手指的列表通过touches[0]以数组的方式来找第几个
                targetTouches:      //当前dom元素上手指的列表，尽量使用这个代替touches
                changedTouches:     //涉及当前事件的手指的列表，尽量使用这个代替touches

                这些列表里的每次触摸由touch对象组成，touch对象里包含着触摸信息，主要属性如下：
                clientX / clientY:      //触摸点相对浏览器窗口的位置
                pageX / pageY:       //触摸点相对于页面的位置
                screenX  /  screenY:    //触摸点相对于屏幕的位置
                identifier:        //touch对象的ID
                target:       //当前的DOM元素
            </pre>
            <div class="explain">document.body.contentEditable='true';利用这个h5的属性可以使得浏览器变得可以编辑</div>

            <div class="title">对js继承的理解</div>
            <pre>
                function定义的对象有一个prototype属性，使用new生成的对象没有这个属性，
                prototype属性又指向了一个prototype对象，这是两个不同的东西，在prototype对象中有一个constructor属性，这个constructor
                属性同样指向了一个constructor对象，而这个对象指向了function函数本身
                function Person(name){
                    this.name=name;
                    this.showMe=function(){
                        console.log(this.name);
                    }
                };
                var one =new Person('js');
                console.log(one.prototype);     //undefined
                console.log(typeof Person.prototype);   //object   该对向包含两个属性，一个是constructor一个是_proto_
                console.log(Person.prototype.constructor);  //打印出函数本身


                function Person(name){
                    this.name=name;
                    this.showMe=function(){
                        console.log(this.name);
                    }
                };
                Person.prototype.form=function(){
                  console.log(123)
                }
                var one =new Person('js');   //一旦实例化之后就是创建相应的内存区块了，会在堆内存中存储三个属性
                {name:js,showMe:function(),_proto_},注意_proto_属性指向的就是Person的prototype对象，所以在给其prototype对象加
                属性之后可以访问到了
                one.showMe();     //js      
                one.form();   //123 

                function Person(name){
                    this.name=name;
                    this.showMe=function(){
                        console.log(this.name);
                    }
                };
                Person.prototype.form=function(){
                  console.log(123)
                }
                function sub(){}
                sub.prototype=new Person();
                //sub.prototype.constructor=sub;  //加了这句话之后其实就是在sub的原型对象中加入一个constructor属性，使其构造者
                指向sub，这样他就不会再向上找原型链找到constructor属性，这时候就指向了Person
                var subone=new sub();
                console.log(subone);   //{_proto_:Person}
                subone.form();   //123
                console.log(subone.constructor); //function Person(){}
                console.log(sub.prototype.constructor); //function Person(){}  
            </pre>
            <div class="explain">以上就是所谓的继承，只需要把子类的prototype设置为父类的一个实例化对象即可</div>

            <div class="title">js实现二分法排序代码</div>
            <pre>
                var quicksort = function(arr){
                    if(arr.length <= 1){
                        return arr;
                    }
                    var pivotIndex = Math.floor(arr.length / 2);
                    var pivot = arr.splice(pivotIndex,1)[0];
                    var left = [];
                    var right = [];
                    for(var i = 0;i < arr.length;i++){
                        if(arr[i] < pivot){
                            left.push(arr[i]);
                        }else{
                            right.push(arr[i]);
                        }
                    }
                    return quicksort(left).concat([pivot],quicksort(right));
                };

                var array = [8,7,0,7,5,2,5,3,1];
                quicksort(array); //[0,1,2,3,5,5,7,7,8]
            </pre>

            <div class="title">js常用小技巧总结</div>
            <pre>
                 1.有时候我们需要对一个变量查检其是否存在或者检查值是否有一个有效值，如果存在就返回true值。
                 为了做这样的验证，我们可以使用!!操作符来实现是非常的方便与简单。对于变量可以使用!!variable做检测，
                 只要变量的值为:0、null、" "、undefined或者NaN都将返回的是false，反之返回的是true。比如下面的示例：
                 function Account(cash) {
                     this.cash = cash;
                     this.hasMoney = !!cash;
                 }
                 var account = new Account(100.50);
                 console.log(account.cash); // 100.50
                 console.log(account.hasMoney); // true

                 var emptyAccount = new Account(0);
                 console.log(emptyAccount.cash); // 0
                 console.log(emptyAccount.hasMoney); // false
                 
                 2.使用+将字符串转换成数字，不过其只适合用于字符串数据，否则将返回NaN
                 function toNumber(strNumber) {
                     return +strNumber;
                 }
                 console.log(toNumber("1234")); // 1234
                 console.log(toNumber("ACB")); // NaN
                 console.log(+new Date()) // 1461288164385

                 3.对于：
                 if (conected) {
                     login();
                 }可以简写为：conected && login();
                 如果一些属性或函数存在于一个对象中，你也可以这样做检测，如下面的代码所示：user && user.login();
                 对于||判断也是如此，如果第一个为true则后面不走，否则就走

                 4.如果是一个小型数组，这样做很好，如果你要处理的是一个大的数组，这段代码在每次迭代都将会重新计算数组的大小，这
                 将会导致一些延误。为了避免这种现象出现，可以将array.length做一个缓存：
                 for(var i = 0; i < array.length; i++) {
                     console.log(array[i]);
                 }
                 可以改为：
                     var length = array.length;
                     for(var i = 0; i < length; i++) {
                         console.log(array[i]);
                     }或者：
                     for(var i = 0, length = array.length; i < length; i++) {
                         console.log(array[i]);
                     }

                 5.合并数组：
                    var array1 = [1,2,3];
                    var array2 = [4,5,6];
                    console.log(array1.concat(array2)); // [1,2,3,4,5,6];
                    这个函数并不适合用来合并两个大型的数组，因为其将消耗大量的内存来存储新创建的数组
                    应该如此：console.log(array1.push.apply(array1, array2));

                 6.将NodeList转换成数组
                 如果你运行document.querySelectorAll(“p”)函数时，它可能返回DOM元素的数组，也就是NodeList对象。但这个对象不具
                 有数组的函数功能;
                 var elements = document.querySelectorAll("p"); // NodeList
                 var arrayElements = [].slice.call(elements); // Now the NodeList is an array

                 7.对于需要遍历是否错误的时候可以
                 var flag=true;                
                 在一个正确的事件中：  flag=flag && true
                 在一个错误的事件中：  flag=false;
                 这样只要flag错一次，那就即使运行正确事件几次也注定是false了

                 8.找到非单字节字符的换成两个单字节的，再求长度，可计总长度
                 str.replace(/[^\00-xff]/g,"xx").length;
                 web安全中的攻击:将img标签的src=0 onerror=alert(5)这样就有效荷载可以造成xss攻击
                 当src写值的时候可以请求到其他网站的文件，例如js文件就可以进行跨站请求攻击

                 9.js判断数据类型
                 使用 typeof 运算符判断一个原始值变量的类型还有undefined是没有问题的，
                 但如果判断的是引用值类型就会有局限性，比如 null 和数组的结果都是 object
                 要想判断变量属于哪种内置类型，最靠谱的方式是调用 Object.prototype.toString 方法：
                 Object.prototype.toString.call([])
                 // => "[object Array]"
                 Object.prototype.toString.call(null)
                 // => "[object Null]"
                 Object.prototype.toString.call(undefined)
                 // => "[object Undefined]"
                 注意对象的toString方法和数组和字符串的toString方法是不一样的一个检测的一个用来转换为字符串
            </pre>

            <div class="title">数组去重的方法</div>
            <pre>
                function unique1() {
                   var newArray = [];
                   this.forEach(function (index) {
                       if (newArray.indexOf(index) == -1) {
                           newArray.push(index);
                       }
                   });
                   return newArray;
                }
                通过unique1.apply(arr)或unique1.call(arr)调用

                Array.prototype.unique3 = function () {
                     // 构建一个新数组存放结果
                     var newArray = [];
                     // 创建一个空对象
                     var object = {};
                     // for循环时，每次取出一个元素与对象进行对比
                     // 如果这个元素不重复，则将它存放到结果数中
                     // 同时把这个元素的内容作为对象的一个属性，并赋值为1,
                     // 存入到第2步建立的对象中
                     for (var i = 0; i < this.length; i++){
                         // 检测在object对象中是否包含遍历到的元素的值
                         if(!object[typeof(this[i]) + this[i]]) {
                             // 如果不包含，将存入对象的元素的值推入到结果数组中typeof(this[i]) + this[i]在拼一个键
                             newArray.push(this[i]);
                             // 如果不包含，存入object对象中该属性名的值设置为1
                             object[typeof(this[i]) + this[i]] = 1;
                         }
                     }
                     return newArray;
                }
                var arr = [1,2,3,4,'a','b',1,3,4,56,32,34,2,'b','c',5,'1','2'];
                arr.unique3(); // [1, 2, 3, 4, "a", "b", 56, 32, 34, "c", 5, "1", "2"]
                但是不同的键可能会被误认为一样；例如： a[1]、a["1"] 这种方法所费时间是最短，但就是占用内存大一些。
            </pre>

            <div class="title">h5使用formdata实现文件上传</div>
            <pre>
            表单中enctype="multipart/form-data"的意思是设置表单的MIME编码,默认编码格式是application/x-www-form-urlencoded
            不能用于文件上传；只有使用了multipart/form-data，才能完整的传递文件数据，进行下面的操作.
            form设置了enctype="multipart/form-data" 属性后，就是2进制传输数据了 

            FormData可以把它理解成一个虚拟的表单对象，它只有一个方法append，这个可以在浏览器console一下就知道了。
            我们可以通过append向FormData里面添加各种需要提交的数据
            你可以先创建一个空的 FormData 对象,然后使用 append() 方法向该对象里添加字段，如下：var oMyForm = new FormData();
            oMyForm.append("username", "Groucho");
            oMyForm.append("accountnum", 123456); // 数字123456被立即转换成字符串"123456"           
            // fileInputElement中已经包含了用户所选择的文件
            oMyForm.append("userfile", fileInputElement.files[0]);var oReq = new XMLHttpRequest();
            oReq.open("POST", "http://foo.com/submitform.php");
            oReq.send(oMyForm);

            如果已经有一个Form表单，只需要把这个 form 元素作为参数传入 FormData 构造函数即可：
            var formElement = document.getElementById("myFormElementid");
            formData = new FormData(formElement);
            //你还可以在已有表单数据的基础上，继续添加新的键值对，如下：
            formData.append("serialnumber", serialNumber++);
            var oReq = new XMLHttpRequest();
            oReq.open("POST", "submitform.php");
            oReq.send(formData);

            //基于jquery的时候
            var fd = new FormData(document.getElementById("fileinfo"));
            fd.append("CustomField", "This is some extra data");
            $.ajax({
              url: "stash.php",
              type: "POST",
              data: fd,
              processData: false,  // 告诉jQuery不要去处理发送的数据
              contentType: false   // 告诉jQuery不要去设置Content-Type请求头
            });

            //一个完整的例子
            var form=document.getElementById("form1");
            var formData=new FormData(form);
            var oReq = new XMLHttpRequest();
            oReq.onreadystatechange=function(){
              if(oReq.readyState==4){
                if(oReq.status==200){
                   
                }
              }
            }
            oReq.open("POST", "server.php");
            oReq.send(formData);
            </pre>

            <div class="title">Object.defineproperty实现数据和视图的联动</div>
            <pre>
            var o = {}; // 创建一个新对象
            // Example of an object property added with defineProperty with a data property descriptor
            Object.defineProperty(o, "a", {value : 37,
                                           writable : true,
                                           enumerable : true,
                                           configurable : true});
            // 对象o拥有了属性a，值为37

            // Example of an object property added with defineProperty with an accessor property descriptor
            var bValue;
            Object.defineProperty(o, "b", {get : function(){ return bValue; },
                                           set : function(newValue){ bValue = newValue; },
                                           enumerable : true,
                                           configurable : true});
            o.b = 38;  
            给对象o定义新的属性b，并且定义属性b的get和set方法，当o.b的时候会调用b属性的get方法，给b属性赋值的时候，会调用set方法，
            这就是修改数据的时候，视图会自动更新的关键前端获取数据后，需要根据数据操作dom，视图变化后，需要修改不少代码，
            有没有方法将数据和dom操作隔离，看一个例子 
            <textarea style="height:110px;">
                <div>
                    <p>你好，<span id='nickName'></span></p>
                    <div id="introduce"></div>
                </div>　
            </textarea>
            //视图控制器
            var userInfo = {};
            Object.defineProperty(userInfo, "nickName", {
                get: function(){
                    return document.getElementById('nickName').innerHTML;
                },
                set: function(nick){
                    document.getElementById('nickName').innerHTML = nick;
                }
            });
            Object.defineProperty(userInfo, "introduce", {
                get: function(){
                    return document.getElementById('introduce').innerHTML;
                },
                set: function(introduce){
                    document.getElementById('introduce').innerHTML = introduce;
                }
            })
            userInfo.nickName = "赋值";
            userInfo.introduce = "赋值"
            设置userInfo的nickName属性时会调用set方法，更新dom节点的html
            </pre>
            <div class="explain">大多数框架都是用这个来实现绑定例如vue.js。把一个普通对象传给 Vue 实例作为它的 data 选项，Vue.js 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。这是 ES5 特性，不能打补丁实现，这便是为什么 Vue.js 不支持 IE8 及更低版本</div>

            <div class="title">递归调用的优化</div>
            <pre>
            它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？
            就是采用“循环”换掉“递归”。

            下面是一个正常的递归函数。
            function sum(x, y) {
              if (y > 0) {
                return sum(x + 1, y - 1);
              } else {
                return x;
              }
            }
            sum(1, 100000)
            // Uncaught RangeError: Maximum call stack size exceeded(…)
            上面代码中，sum是一个递归函数，参数x是需要累加的值，参数y控制递归次数。一旦指定sum递归100000次，就会报错，提示超出调用栈的
            最大次数。
            蹦床函数（trampoline）可以将递归执行转为循环执行。

            function trampoline(f) {
              while (f && f instanceof Function) {
                f = f();
              }
              return f;
            }
            上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执
            行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。

            然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。

            function sum(x, y) {
              if (y > 0) {
                return sum.bind(null, x + 1, y - 1);
              } else {
                return x;
              }
            }
            上面代码中，sum函数的每次执行，都会返回自身的另一个版本。

            现在，使用蹦床函数执行sum，就不会发生调用栈溢出。

            trampoline(sum(1, 100000))   
            </pre>

            <div class="title">正则表达式小结</div>
            <pre>
            '12345678'.replace(/\d{3,6}/g,'X')       //output: "X78"
            正常情况下就是贪婪模式，就是直接按最多次匹配，匹配一次之后就扔掉匹配的123456，只剩下78了所以只有一次匹配
            '12345678'.replace(/\d{3,6}?/g,'X')       //output: "XX78"
            '123456789'.match(/\d{3,5}?/g)       //output: ["123","456","789"]
            在量词后面加上?就表示非贪婪模式，对应匹配到最小个数的值,这里就匹配三个数字就行了
            'a1b2c3d4'.replace(/([a-z]\d){3}/g,"X")   //output: "Xd4"
            量词最大作用是要给括号分组，这里没有括号的话就表示3个数字了


            'byroncasper'.replace(/byron|casper/g,"X")   //output:"XX"
            'byronsperbyrcasper'.replace(/byr(on|ca)sper/g,"X")   //output:"XX"
            注意分组中或'|'的使用，直接表示左右两个单词，注意上面有无括号的区别


            分组中的反向引用：
            '2015-12-25'.replace(/(\d{4})-(\d{2})-(\d{2})/g,'$2/$3/$1')   //output:12/25/2015
            没有括号的时候就表示$1这样的直接的字符串，有括号的时候就是会被捕获就是值，但是我们也可以在分组后面加?:就可以不被
            捕获如(?:abc)这样后面就捕获不到了


            正则表达式中的前瞻也就是正向匹配
            'a2cc'.replace(/\w(?=\d)/g,'X')     //output:'X2cc'
            意思是满足是字母而且后面是一个数字的情况，注意括号里面的不参与匹配，只有在前一个符合情况下才看匹配的那个后面是否符合，
            那么?!就表示不符合括号内的这叫负向匹配

            var reg1=/\w/;
            var reg2=/\w/g;   //注意lastIndex是正则的属性
            reg1.test('ab');  //无论执行多少次都是true,因为lastIndex值始终为0
            console.log(reg1.lastIndex);      // 0
            console.log(reg2.lastIndex);      // 0
            console.log(reg2.test('ab'));     // true
            console.log(reg2.lastIndex);      // 1
            console.log(reg2.test('ab'));     // true
            console.log(reg2.lastIndex);      // 2
            console.log(reg2.test('ab'));     // false
            console.log(reg2.lastIndex);      // 0
            console.log(reg2.test('ab'));     // true
            console.log(reg2.lastIndex);      // 1
            console.log(reg2.test('ab'));     // true
            console.log(reg2.lastIndex);      // 2
            console.log(reg2.test('ab'));     // false
            console.log(reg2.lastIndex);      // 0
            while(reg2.test('ab')){
               console.log(reg2.lastIndex);   // 1 2
            }
            lastIndex返回每次匹配的最后一个字符的下一位，以便下一次匹配（非全局模式下始终为0），最后没了的时候又重置为0.
            所以为了使结果一样有时候这样写每一次都实例化一个正则，但是这耗内存(/\W/g).test('ab')
            但是test只是为了检测用，所以用这个方法的时候我们一般不用全局匹配


            var reg3=/\d(\w)(\w)\d/;
            var reg4=/\d(\w)(\w)\d/g;
            var ts='$1ab2bb3cy4dd5ee';
            var ret=reg3.exec(ts);
            console.log(ret);             //["1ab2", "a", "b", index: 1, input: "$1ab2bb3cy4dd5ee"]
            console.log(ret.index);       // 1
            console.log(ret[0]);          // "1ab2"
            console.log(ret.toString());  //"1ab2,a,b"    这是一个字符串
            其中ret是一个对象数组，第一个表示匹配到的值，后面是对应的分组匹配到的值，有几个分组，就有几个这个值，index值对应匹配到的
            字符串的开始位置，input对应你要查询的原字符串
            while(reg4.exec(ts)){
               console.log(reg4.lastIndex + ret.index + ret.toString());   
            }
            //"5 1 1ab2,a,b"     "11 7 3cy4,c,y"     输出值同非全局模式下面的一样只是多了循环而已


            'a1b2c3d1'.search('1')     //output:1
            search方法用于查找返回匹配到的字符串的开始位置没找到就返回-1,这个方法忽略/g标志
            实际上对于字符串的像split,replace等方法最终都是隐式转换为正则表达式的
            'a,b,c,d'.split(',')会被转换为'a,b,c,d'.split(/,/g)输出['a','b','c','d']
            'a1b2c3d4'.split(/\d/g)以数字为分隔符输出数组['a','b','c','d']


            var reg3=/\d(\w)\d/;
            var reg4=/\d(\w)\d/g;
            var ts='$1a2b3c4d5e';
            var ret=ts.match(reg3);       
            console.log(ret);             //["1a2", "3c4",index: 1, input: "$1a2b3c4d5e"]   
            console.log(ret.index);       //  1
            console.log(ret[0]);          // "1a2"
            console.log(ret.toString());  //"1a2,3c4"    这是一个字符串
            match方法非全局模式下返回值和exec一样，没有匹配到的时候返回null 
            var ret2=ts.match(reg4);       
            console.log(ret2);             //["1a2", "3c4"]   
            console.log(ret2.index);       //  undefined
            console.log(ret2[0]);          // "1a2"
            全局模式下只是返回匹配值的对象数组，没有就返回null，这个功能比exec弱一些，但是速度快一些


            'a1b2c3d45e'.replace(/(\d)(\w)(\d)/g,function(match,group1,group2,group3,index,origin){
                console.log(match);
                return group1+group3;
            })
            match代表匹配到的项，所以依次输出"1b2"  "3d4",最终返回的字符串是"a12c34e5"
            group1,group2,group3代表匹配下的分组，没有分组的时候就没有几个分组值的参数
            index代表匹配到的开始位置，origin代表原始字符串
            </pre>
            <div class="explain">注意上面的返回值都新开了内存区块，原字符串并没有改变</div>

       	</div>
       
  </body>
</html>
