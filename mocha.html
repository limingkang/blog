<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Blog by limingkang</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <!-- <link rel="stylesheet" href="stylesheets/github-light.css"> -->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="前端开发记录">
    <meta name="keywords" content="gulp,react,node,webpack,redux,require,mysql,mongodb">
  </head>
  <body>
       <div class="big_container">
           <div class="title">mocha测试的使用</div>
           <pre>
        module.parent来确定调用关系
        a.js:

        	if (!module.parent) {
        	    console.log("I'm parent");
        	} else {
        	    console.log("I'm child");
        	}

        b.js:

        	require('./a')

        run node a.js will output:
        I'm parent

        run node.b.js will output:
        I'm child


        require一个模块实际上就是运行了这个模块，不管其在导出函数的后面还是哪里




        当然使用之前请全局下载mocha，最后用mocha来启动test文件,mocha中还要是用chai模块的断言功能,记住describe和it里面的值都会打印出来
        mocha的使用方法十分简单，就是两个语句describe和it
        describe('req.get',function(){
            describe('res.json',function(){
            });
        });
        被describe的回调所包裹的是一个测试流程，使用describe可以很好地为测试表明目的和区分层次，就是随便写的一些描述

        describe('Array.index',function(){
            it('should return -1 when not found',function(){
                var tmp=[1,2,3];
                tmp.indexOf(4).should.equal(-1);
            });
        });
        it的第一个参数是个字符串，你可以把它看做是你测试样例的期望结果，其实没有什么实际意义，不会对测试样例的运行有什么影响。
        在异步的时候：
        describe('db.save',function(){
            it('should save the doc',function(done){
                doc.save(function(err,doc){
                    if(err) done(err);
                    if(!doc) done(err);
                    done();
                });
            });
        });
        done是链的最后一个步骤，调用done即不会往下执行，done(err)则说明失败。








        对后端测试的时候难免会发起请求，supertest为我们提供了这样的功能。
        	var request=require('supertest');
        	request(app).
        	    get('/foo').
        	    expect(200).
        	    //expect表示希望接受到的东西，希望状态码200，希望返回的内容类型
        	    expect('Content-Type','application/json').      
        	    end(function(err,res){
        	        if(err) throw err;
        	    });
        模拟异步ajax：
            //json上传
            request(app).
                post('/foo').
                send({key:'value'}).
                expect(200);
            //表单提交
            request(app).
                post('/foo').
                type('form').
                send({key:value});
            //上传文件
            request(app).
                post('/foo').
                attach('field','filepath').
                ....

        describe('test async function', function(){ 
            it('supertest example', function(done){ 
                request.post('/') 
                .expect(200) 
                .end(function(err, res) { 
                    should.not.exist(err); done(); })
                 }) 
        })
        在request请求执行完毕end()之后，一定要调用done()，否则测试用例超时，那么这个用例就失败了








        Mocha的Hooks主要是用来设置前置条件和后置处理。比如说一个业务请求之前必须先登录，那个登录操作就在before()里面完成。
        Mocha提供了before,after,beforeEach,afterEach四个钩子。
           describe('hooks', function() {
              before(function() { 
                // runs before all tests in this block
              }); 
              after(function() { 
              // runs after all tests in this block 
              }); 
              beforeEach(function() { 
              // runs before each test in this block 
              }); 
              afterEach(function() { 
              // runs after each test in this block 
              });
               it('test',function(done){ 
               //test here 
               }) 
           });
        如果说某个测试需要跳过，使用it.skip()，Mocha跳过这个用例而不影响其他it块；只测试某个测试用例，使用it.only()，
        Mocha只执行.only用例，无视其他it块。







        检查给定的 type(s) 是否 acceptable, 如果是, 则返回最佳的匹配, 否则 false, 这时应该响应 406 "Not Acceptable".

        type 值应该是一个或多个 mime 字符串, 例如 "application/json", 扩展名如 "json", 或数组 ["json", "html", "text/plain"]. 
        如果给定一个 list 或 array, 会返回最佳(best)匹配项.

        如果请求 client 没有发送 Accept header, 会返回第一个 type.
        // Accept: text/html
        this.accepts('html');
        // => "html"

        // Accept: text/*, application/json
        this.accepts('html');
        // => "html"
        this.accepts('text/html');
        // => "text/html"
        this.accepts('json', 'text');
        // => "json"
        this.accepts('application/json');
        // => "application/json"

        // Accept: text/*, application/json
        this.accepts('image/png');
        this.accepts('png');
        // => false

        // Accept: text/*;q=.5, application/json
        this.accepts(['html', 'json']);
        this.accepts('html', 'json');
        // => "json"

        // No Accept header
        this.accepts('html', 'json');
        // => "html"
        this.accepts('json', 'html');
        // => "json"
        this.accepts() 可以被多次调用, 或使用在 switch.

        switch (this.accepts('json', 'html', 'text')) {
          case 'json': break;
          case 'html': break;
          case 'text': break;
          default: this.throw(406, 'json, html, or text only');
        }



        var expect = require('chai').expect;
        // 相等或不相等
        expect(4 + 5).to.be.equal(9);
        expect(4 + 5).to.be.not.equal(10);
        expect(foo).to.be.deep.equal({ bar: 'baz' });

        // 布尔值为true
        expect('everthing').to.be.ok;
        expect(false).to.not.be.ok;

        // typeof
        expect('test').to.be.a('string');
        expect({ foo: 'bar' }).to.be.an('object');
        expect(foo).to.be.an.instanceof(Foo);

        // include
        expect([1,2,3]).to.include(2);
        expect('foobar').to.contain('foo');
        expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');

        // empty
        expect([]).to.be.empty;
        expect('').to.be.empty;
        expect({}).to.be.empty;

        // match
        expect('foobar').to.match(/^foo/);
           </pre>
       </div>
  </body>
</html>
