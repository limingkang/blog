<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Blog by limingkang</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <!-- <link rel="stylesheet" href="stylesheets/github-light.css"> -->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="前端开发记录">
    <meta name="keywords" content="gulp,react,node,webpack,redux,require,mysql,mongodb">
  </head>
  <body>
       <div class="big_container">
           <div class="title" style="margin-top:0;">vue.js与其他框架的比较</div>
           <pre>
        Vue 与 Angular的比较：
           1.vue的api比angular简单，易于学习，它允许你自定义组织应用程序的方式，不必任何时候都遵循angular规则，它仅仅是一个视图层，
           所以你可以将它嵌入一个现有页面而不一定要做成一个庞大的单页应用。在配合其他库方面它给了你更大的的空间，但相应，
           你也需要做更多的架构决策。例如，Vue.js 核心默认不包含路由和 Ajax 功能，并且通常假定你在应用中使用了一个模块构建系统
           2.Angular 使用双向绑定，Vue 也支持双向绑定，不过默认为单向绑定，数据从父组件单向传给子组件。在大型应用中使用单向绑定让
           数据流易于理解
           3.Vue.js 有更好的性能，并且非常非常容易优化，因为它不使用脏检查。Angular，当 watcher 越来越多时会变得越来越慢，因为作用域
           内的每一次变化，所有 watcher 都要重新计算。并且，如果一些 watcher 触发另一个更新，脏检查循环（digest cycle）可能要运行多次
           Angular 用户常常要使用深奥的技术，以解决脏检查循环的问题。有时没有简单的办法来优化有大量 watcher 的作用域。Vue.js 则根本
           没有这个问题，因为它使用基于依赖追踪的观察系统并且异步列队更新，所有的数据变化都是独立地触发，除非它们之间有明确的依赖关系
           唯一需要做的优化是在 v-for 上使用 track-by

        vue和react的比较：
           1.React 的渲染建立在 Virtual DOM 上——一种在内存中描述 DOM 树状态的数据结构。当状态发生变化时，React 重新渲染 Virtual DOM
           比较计算之后给真实 DOM 打补丁。Virtual DOM 提供了一个函数式的方法描述视图，这真的很棒。因为它不使用数据观察机制，每次
           更新都会重新渲染整个应用，因此从定义上保证了视图与数据的同步。它也开辟了 JavaScript 同构应用的可能性
           2.Vue.js 不使用 Virtual DOM 而是使用真实 DOM 作为模板，数据绑定到真实节点。Vue.js 的应用环境必须提供 DOM。但是，相对于常
           见的误解——Virtual DOM 让 React 比其它的都快， Vue.js 实际上性能比 React 好，而且几乎不用手工优化。而 React，为了最优化的
           渲染需要处处实现 shouldComponentUpdate 和使用不可变数据结构
           3.在 API 方面，React（或 JSX）的一个问题是，渲染函数常常包含大量的逻辑，最终看着更像是程序片断（实际上就是）而不是界面的
           视觉呈现。对于部分开发者来说，他们可能觉得这是个优点，但对那些像我一样兼顾设计和开发的人来说，模板能让我们更好地在视觉上
           思考设计和 CSS。JSX 和 JavaScript 逻辑的混合干扰了我将代码映射到设计的思维过程。相反，Vue.js 通过在模板中加入一个轻量级
           的 DSL (指令系统)，换来一个依旧直观的模板，且能将逻辑封装进指令和过滤器中
           4.React 的另一个问题是：由于 DOM 更新完全交给 Virtual DOM 管理，当想要自己控制 DOM 时就有点棘手了（虽然理论上可以做到，但
           这样做就本质上违背了 React 的设计思想）。如果应用需要特别的自定义 DOM 操作，特别是复杂时间控制的动画，这个限制就很讨厌。
           在这方面，Vue.js 更灵活
           5.对于大型应用，React 社区已经创造了大量的状态管理方案，例如 Flux/Redux。Vue 本身不解决这个问题（React 内核也是）,但是可以
           轻松地修改状态管理模式，实现一个类似的架构。Vue 有自己的状态管理方案 Vuex，而且 Vue 也可以与 Redux 一起用
           6.React 的开发趋势是将所有东西都放在 JavaScript 中，包括 CSS。已经有许多 CSS-in-JS 方案，但是所有的方案多多少少都有问题
           而且更重要的是，这么做脱离了标准的 CSS 开发经验，并且很难和 CSS 社区的已有工作配合。Vue 的 单文件组件 在把 CSS 封装到组件
           模块的同时仍然允许你使用你喜欢的预处理器

        vue和ember的比较：
           1.Ember 是一个全能框架。它提供大量的约定，一旦你熟悉了它们，开发会很高效。不过，这也意味着学习曲线较高，而且不灵活。在框架
           和库（加上一系列松散耦合的工具）之间权衡选择。后者更自由，但是也要求你做更多的架构决定。也就是说，最好比较 Vue.js 内核和
           Ember 的模板与数据模型层
           2.Vue在普通JavaScript对象上建立响应，提供自动化的计算属性。在Ember中要将所有东西放在Ember对象内，并且手工为计算属性声明依赖
           3.Vue 的模板语法可以用全功能的 JavaScript 表达式，而 Handlebars 的语法和帮助函数语法相比之下非常受限
           4.在性能上，Vue甩开Ember几条街，即使是Ember 2.0最新的Glimmer引擎。Vue 自动批量更新，在性能比较关键时 Ember 要手工管理循环
           </pre>
           <div class="explain">vue.js中文文档地址<a href="http://cn.vuejs.org/guide/installation.html">http://cn.vuejs.org/guide/installation.html</a></div>
           <div class="explain">vue.js中文社区地址<a href="http://forum.vuejs.org/category/10/%E4%B8%AD%E6%96%87">http://forum.vuejs.org/category/10/%E4%B8%AD%E6%96%87</a></div>
           <div class="explain">vue-router单页应用插件地址<a href="http://router.vuejs.org/zh-cn/installation.html">http://router.vuejs.org/zh-cn/installation.html</a></div>
       	   <div class="explian">对于sublime先下插件Vuejs Snippets和Vue Syntax Highlight，这样便于.vue文件的开发,具体项目应用可去github中查看</div>

           <div class="title">实例的生命周期</div>
           <pre>
        Vue 实例在创建时有一系列初始化步骤——例如，它需要建立数据观察，编译模板，创建必要的数据绑定。在此过程中，它也将调用一些生命
        周期钩子，给自定义逻辑提供运行机会。例如 created 钩子在实例创建后调用：
	        var vm = new Vue({
	          data: {
	            a: 1
	          },
	          created: function () {
	            // `this` 指向 vm 实例
	            console.log('a is: ' + this.a)
	          }
	        })
	        // -> "a is: 1"
        也有一些其它的钩子，在实例生命周期的不同阶段调用，如 compiled、 ready 、destroyed。钩子的 this 指向调用它的 Vue 实例。
        Vue.js没有是没有控制器的概念的，组件的自定义逻辑可以分割在这些钩子中
           </pre>
           <div class="explain">具体详细生命周期可查官方文档</div>

           <div class="title">条件渲染v-if和v-show的区别</div>
           <pre>
        在切换 v-if 块时，Vue.js 有一个局部编译/卸载过程，因为 v-if 之中的模板也可能包括数据绑定或子组件。v-if 是真实的条件渲染，因为
        它会确保条件块在切换当中合适地销毁与重建条件块内的事件监听器和子组件。
        v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——在条件第一次变为真时才开始局部编译（编译会被缓存起来）。
        相比之下，v-show 简单得多——元素始终被编译并保留，只是简单地基于 CSS 切换。
        一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能
        改变v-if 较好。
           </pre>

           <div class="title">数组变动检测</div>
           <pre>
        1.Vue.js 包装了被观察数组的变异方法，故它们能触发视图更新。被包装的方法有：
        	push()、pop()、shift()、unshift()、splice()、sort()、reverse()
        	你可以打开浏览器的控制台，用这些方法修改上例的 items 数组。例如：example1.items.push({ message: 'Baz' })   	
        
        2.变异方法，如名字所示，修改了原始数组。相比之下，也有非变异方法，如 filter(), concat() 和 slice()，不会修改原始数组而是返回
        一个新数组。在使用非变异方法时，可以直接用新数组替换旧数组：
			example1.items = example1.items.filter(function (item) {
			  return item.message.match(/Foo/)
			})
	可能你觉得这将导致 Vue.js 弃用已有 DOM 并重新渲染整个列表——幸运的是并非如此。 Vue.js 实现了一些启发算法，以最大化复用 DOM 元素
	因而用另一个数组替换数组是一个非常高效的操作

	3.有时需要用全新对象（例如通过 API 调用创建的对象）替换数组。因为 v-for 默认通过数据对象的特征来决定对已有作用域和 DOM 元素的
	复用程度，这可能导致重新渲染整个列表。但是，如果每个对象都有一个唯一 ID 的属性，便可以使用 track-by 特性给 Vue.js 一个提示，
	Vue.js 因而能尽可能地复用已有实例。例如，假定数据为：
		{
		  items: [
		    { _uid: '88f869d', ... },
		    { _uid: '7496c10', ... }
		  ]
		}
	然后可以这样给出提示：
	<textarea>
		<div v-for="item in items" track-by="_uid"><!-- content --></div>
	</textarea>
    	然后在替换数组 items 时，如果 Vue.js 遇到一个包含 _uid: '88f869d' 的新对象，这个对象的_uid和上面的一样，只是其他值不一样,
    	它知道它可以复用这个已有对象的作用域与DOM 元素。
           
        4.因为 JavaScript 的限制，Vue.js 不能检测到下面数组变化：
		直接用索引设置元素，如 vm.items[0] = {}；
		修改数据的长度，如 vm.items.length = 0。
	为了解决问题 (1)，Vue.js 扩展了观察数组，为它添加了一个 $set() 方法：
		// 与 `example1.items[0] = ...` 相同，但是能触发视图更新
		example1.items.$set(0, { childMsg: 'Changed!'})
		至于问题 (2)，只需用一个空数组替换 items。
	除了 $set()， Vue.js 也为观察数组添加了 $remove() 方法，用于从目标数组中查找并删除元素，在内部它调用 splice().不必这样：
		var index = this.items.indexOf(item)
		if (index !== -1) {
		  this.items.splice(index, 1)
		}
	只用这样：
		this.items.$remove(item)
	使用 Object.freeze()在遍历一个数组时，如果数组元素是对象并且对象用 Object.freeze() 冻结，你需要明确指定 track-by。在这
	种情况下如果 Vue.js 不能自动追踪对象，将给出一条警告
           </pre>

           <div class="title">事件处理</div>
           <pre>
        1.事件处理器限制为一个语句，有时也需要在内联语句处理器中访问原生 DOM 事件。可以用特殊变量 $event 把它传入方法：
        <textarea>
        	<button v-on:click="say('hello!', $event)">Submit</button>
        </textarea> 
        methods: {
          say: function (msg, event) {
            // 现在我们可以访问原生事件对象
            event.preventDefault()
          }
        }
        2.在事件处理器中经常需要调用 event.preventDefault() 或 event.stopPropagation()。尽管我们在方法内可以轻松做到，不过让方法
        是纯粹的数据逻辑而不处理 DOM 事件细节会更好。为了解决这个问题，Vue.js 为 v-on 提供两个 事件修饰符：.prevent 与 .stop 
        <textarea style="height:720px;">
        	<!-- 阻止单击事件冒泡 -->
        	<a v-on:click.stop="doThis"></a>

        	<!-- 提交事件不再重载页面 -->
        	<form v-on:submit.prevent="onSubmit"></form>

        	<!-- 修饰符可以串联 -->
        	<a v-on:click.stop.prevent="doThat">

        	<!-- 只有修饰符 -->
        	<form v-on:submit.prevent></form>

        	1.0.16 添加了两个额外的修饰符：
        	<!-- 添加事件侦听器时使用 capture 模式 -->
        	<div v-on:click.capture="doThis">...</div>

        	<!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 -->
        	<div v-on:click.self="doThat">...</div>

        	全部的按键别名：enter,tab,delete,esc,space,up,down,left,right
        	<!-- 只有在 keyCode 是 13 时调用 vm.submit() -->
        	<input v-on:keyup.13="submit">

        	<!-- 同上 -->
        	<input v-on:keyup.enter="submit">

        	<!-- 缩写语法 -->
        	<input @keyup.enter="submit">

        	1.0.17+： 可以自定义按键别名：可以使用 @keyup.f1
        	Vue.directive('on').keyCodes.f1 = 112
        </textarea> 	
           </pre>

           <div class="title">表单控件绑定</div>
           <pre>
        对于单选按钮，勾选框及选择框选项，v-model 绑定的 value 通常是静态字符串（对于勾选框是逻辑值）：
        <textarea style="height:250px;">
        <!-- 当选中时，`picked` 为字符串 "a" -->
        <input type="radio" v-model="picked" value="a">

        <!-- `toggle` 为 true 或 false -->
        <input type="checkbox" v-model="toggle">

        <!-- 当选中时，`selected` 为字符串 "abc" -->
        <select v-model="selected">
          <option value="abc">ABC</option>
        </select>	
        </textarea>
        但是有时我们想绑定 value 到 Vue 实例的一个动态属性上，这时可以用 v-bind 实现，并且这个属性的值可以不是字符串
        <textarea style="height:316px;">
        	<input
        	  type="checkbox"
        	  v-model="toggle"
        	  v-bind:true-value="a"
        	  v-bind:false-value="b">
        	// 当选中时
        	vm.toggle === vm.a
        	// 当没有选中时
        	vm.toggle === vm.b

        	<input type="radio" v-model="pick" v-bind:value="a">
        	// 当选中时
        	vm.pick === vm.a
        </textarea>

        在默认情况下，v-model 在input 事件中同步输入框值与数据，可以添加一个特性 lazy，从而改到在 change 事件中同步：
        <textarea style="height:66px;">
        	<!-- 在 "change" 而不是 "input" 事件中更新 -->
			<input v-model="msg" lazy>
        </textarea>
        如果想自动将用户的输入转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个特性 number：
        <textarea>
        <input v-model="age" number>
        </textarea>
        debounce 设置一个最小的延时，在每次敲击之后延时同步输入框的值与数据。如果每次更新都要进行高耗操作（例如在输入提示中 Ajax 请求）
        注意 debounce 参数不会延迟 input 事件：它延迟“写入”底层数据。因此在使用 debounce 时应当用 vm.$watch() 响应数据的变化。
        若想延迟 DOM 事件，应当使用 debounce 过滤器。
        <textarea>
        	<input v-model="msg" debounce="500">
        </textarea>
           </pre>

           <div class="title">过渡动画</div>
           <pre>
        通过 Vue.js 的过渡系统，可以在元素从 DOM 中插入或移除时自动应用过渡效果。Vue.js 会在适当的时机为你触发 CSS 过渡或动画，你也
        可以提供相应的 JavaScript 钩子函数在过渡过程中执行自定义的 DOM 操作。为了应用过渡效果，需要在目标元素上使用 transition 特性：
        <textarea>
        	<div v-if="show" transition="my-transition"></div>
        </textarea>
        transition 特性可以与下面资源一起用：
           v-if
           v-show
           v-for （只在插入和删除时触发，使用 vue-animated-list 插件）
           动态组件 （介绍见组件）
           在组件的根节点上，并且被 Vue 实例 DOM 方法（如 vm.$appendTo(el)）触发。
        当插入或删除带有过渡的元素时，Vue 将：
           1.尝试以 ID "my-transition" 查找 JavaScript 过渡钩子对象——通过 Vue.transition(id, hooks) 或 transitions 选项注册。
           如果找到了，将在过渡的不同阶段调用相应的钩子。
           2.自动嗅探目标元素是否有 CSS 过渡或动画，并在合适时添加/删除 CSS 类名。
           3.如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作（插入/删除）在下一帧中立即执行。
           </pre>

           <div class="title">渐进过渡</div>
           <pre>
        transition 与 v-for 一起用时可以创建渐近过渡。给过渡元素添加一个特性 stagger, enter-stagger 或 leave-stagger：
        以下就是为每个项目增加一个100毫秒的延时
        <textarea>
        	<div v-for="item in list" transition="stagger" stagger="100"></div>
        </textarea>

        或者，提供一个钩子 stagger, enter-stagger 或 leave-stagger，以更好的控制：
        Vue.transition('stagger', {
          stagger: function (index) {
            // 每个过渡项目增加 50ms 延时
            // 但是最大延时限制为 300ms
            return Math.min(300, index * 50)
          }
        })
           </pre>

           <div class="title">模板解析</div>
           <pre>
        Vue 的模板是 DOM 模板，使用浏览器原生的解析器而不是自己实现一个。相比字符串模板，DOM 模板有一些好处，但是也有问题，它必须是
        有效的 HTML 片段。一些 HTML 元素对什么元素可以放在它里面有限制。常见的限制：
	        a 不能包含其它的交互元素（如按钮，链接）
	        ul 和 ol 只能直接包含 li
	        select 只能包含 option 和 optgroup
	        table 只能直接包含 thead, tbody, tfoot, tr, caption, col, colgroup
	        tr 只能直接包含 th 和 td
        在实际中，这些限制会导致意外的结果。尽管在简单的情况下它可能可以工作，但是你不能依赖自定义组件在浏览器验证之前的展开结果 
        另一个结果是，自定义标签 不能用在 ul, select, table 等对内部元素有限制的标签内。放在这些元素内部的自定义标签将被提到元素的外面
        因而渲染不正确。例如：template标签 不能用在 table 内，这时应使用 tbody标签，table 可以有多个 tbody，从而可以循环了
        <textarea style="height:160px;">
        	<table>
        	  <tbody v-for="item in items">
        	    <tr>Even row</tr>
        	    <tr>Odd row</tr>
        	  </tbody>
        	</table>
        </textarea>	
           </pre>

           <div class="title">prop绑定类型</div>
           <pre>
        prop 默认是单向绑定：当父组件的属性变化时，将传导给子组件，但是反过来不会。这是为了防止子组件无意修改了父组件的状态——这会让
        应用的数据流难以理解。不过，也可以使用 .sync 或 .once 绑定修饰符显式地强制双向或单次绑定
        <textarea style="height:200px;">
        	<!-- 默认为单向绑定 -->
        	<child :msg="parentMsg"></child>

        	<!-- 双向绑定 -->
        	<child :msg.sync="parentMsg"></child>

        	<!-- 单次绑定 -->
        	<child :msg.once="parentMsg"></child>
        </textarea>   	
           </pre>
           <div class="explain">双向绑定会把子组件的 msg 属性同步回父组件的 parentMsg 属性。单次绑定在建立之后不会同步之后的变化,注意如果 prop 是一个对象或数组，是按引用传递。在子组件内修改它会影响父组件的状态，不管是使用哪种绑定类型</div>

           <div class="title">prop验证</div>
           <pre>
        组件可以为 props 指定验证要求。当组件给其他人使用时这很有用，因为这些验证要求构成了组件的 API，确保其他人正确地使用组件。
        此时 props 的值是一个对象，包含验证要求：
            Vue.component('example', {
              props: {
                // 基础类型检测 （`null` 意思是任何类型都可以）
                propA: Number,
                // 多种类型 (1.0.21+)
                propM: [String, Number],
                // 必需且是字符串
                propB: {
                  type: String,
                  required: true
                },
                // 数字，有默认值
                propC: {
                  type: Number,
                  default: 100
                },
                // 对象/数组的默认值应当由一个函数返回
                propD: {
                  type: Object,
                  default: function () {
                    return { msg: 'hello' }
                  }
                },
                // 指定这个 prop 为双向绑定
                // 如果绑定类型不对将抛出一条警告
                propE: {
                  twoWay: true
                },
                // 自定义验证函数
                propF: {
                  validator: function (value) {
                    return value > 10
                  }
                },
                // 转换函数（1.0.12 新增）
                // 在设置值之前转换值
                propG: {
                  coerce: function (val) {
                    return val + '' // 将值转换为字符串
                  }
                },
                propH: {
                  coerce: function (val) {
                    return JSON.parse(val) // 将 JSON 字符串转换为对象
                  }
                }
              }
            })
           </pre>
           <div class="explain">当 prop 验证失败了，Vue 将拒绝在子组件上设置此值，如果使用的是开发版本会抛出一条警告</div>

           <div class="title">自定义事件</div>
           <pre>
        Vue 实例实现了一个自定义事件接口，用于在组件树中通信。这个事件系统独立于原生 DOM 事件，用法也不同。
        不同于 DOM 事件，Vue 事件在冒泡过程中第一次触发回调之后自动停止冒泡，除非回调明确返回 true
        每个 Vue 实例都是一个事件触发器：
	        使用 $on() 监听事件；
	        使用 $emit() 在它上面触发事件；
	        使用 $dispatch() 派发事件，事件沿着父链冒泡；
	        使用 $broadcast() 广播事件，事件向下传导给所有的后代。

	    简单例子：
	    <textarea style="height:270px;">
	    	<!-- 子组件模板 -->
	    	<template id="child-template">
	    	  <input v-model="msg">
	    	  <button v-on:click="notify">Dispatch Event</button>
	    	</template>

	    	<!-- 父组件模板 -->
	    	<div id="events-example">
	    	  <p>Messages: {{ messages | json }}</p>
	    	  <child></child>第二个方法这里改为<child v-on:child-msg="handle"></child>
	    	</div>
	    </textarea>
	    // 注册子组件
	    // 将当前消息派发出去
	    Vue.component('child', {
	      template: '#child-template',
	      data: function () {
	        return { msg: 'hello' }
	      },
	      methods: {
	        notify: function () {
	          if (this.msg.trim()) {
	            this.$dispatch('child-msg', this.msg)
	            this.msg = ''
	          }
	        }
	      }
	    })
	    // 初始化父组件
	    // 将收到消息时将事件推入一个数组
	    var parent = new Vue({
	      el: '#events-example',
	      data: {
	        messages: []
	      },
	      // 在创建实例时 `events` 选项简单地调用 `$on`
	      events: {
	        'child-msg': function (msg) {
	          // 事件回调内的 `this` 自动绑定到注册它的实例上
	          this.messages.push(msg)
	        }
	      }
	    })
	    或者下面这个更加合理：
	    // 注册子组件
	    // 将当前消息派发出去
	    Vue.component('child', {
	      template: '#child-template',
	      data: function () {
	        return { msg: 'hello' }
	      },
	      methods: {
	        notify: function () {
	          if (this.msg.trim()) {
	            this.$dispatch('child-msg', this.msg)
	            this.msg = ''
	          }
	        }
	      }
	    })
	    // 初始化父组件
	    // 将收到消息时将事件推入一个数组
	    var parent = new Vue({
	      el: '#events-example',
	      data: {
	        messages: []
	      },
	      // 在创建实例时 `events` 选项简单地调用 `$on`
	      methods: {
	        'handle': function (msg) {
	          // 事件回调内的 `this` 自动绑定到注册它的实例上
	          this.messages.push(msg)
	        }
	      }
	    })
           </pre>
           <div class="explain">注意events和methods的区别，当你用events选项的时候实际上是在监听里面的事件，一旦有人分发了这个事件就会触发该函数</div>

           <div class="title">编写可复用的组件</div>
           <pre>
        不能传递数据给组件，因为组件的作用域是孤立的。为了传递数据给组件，应当使用 props，在编写组件时，记住是否要复用组件有好处。一次
        性组件跟其它组件紧密耦合没关系，但是可复用组件应当定义一个清晰的公开接口
        Vue.js 组件 API 来自三部分——prop，事件和 slot：   
        	prop 允许外部环境传递数据给组件；
        	事件 允许组件触发外部环境的 action；
        	slot 允许外部环境插入内容到组件的视图结构内。
        <textarea style="height:220px;">
        	<my-component
        	  :foo="baz"
        	  :bar="qux"
        	  @event-a="doThis"
        	  @event-b="doThat">
        	  <!-- content -->
        	  <img slot="icon" src="...">
        	  <p slot="main-text">Hello!</p>
        	</my-component>
        </textarea>	
           </pre>

           <div class="title">片段实例</div>
           <pre>
        在使用 template 选项时，模板的内容将替换实例的挂载元素。因而推荐模板的顶级元素始终是单个元素
        下面几种情况会让实例变成一个片断实例：
	        模板包含多个顶级元素。
	        模板只包含普通文本。
	        模板只包含其它组件（其它组件可能是一个片段实例）
	        模板根节点有一个流程控制指令，如 v-if 或 v-for。
        这些情况让实例有未知数量的顶级元素，它将把它的 DOM 内容当作片断。片断实例仍然会正确地渲染内容。不过，它没有一个根节点，
        它的 $el 指向一个锚节点，即一个空的文本节点（在开发模式下是一个注释节点）。
        但是更重要的是，组件元素上的非流程控制指令，非 prop 特性和过渡将被忽略，因为没有根元素供绑定：
        <textarea style="height:200px;">
        	<!-- 不可以，因为没有根元素 -->
        	<example v-show="ok" transition="fade"></example>

        	<!-- props 可以 -->
        	<example :prop="someData"></example>

        	<!-- 流程控制可以，但是不能有过渡 -->
        	<example v-if="ok"></example>
        </textarea>
           </pre>
           <div class="explain">当然片断实例有它的用处，不过通常给组件一个根节点比较好。它会保证组件元素上的指令和特性能正确地转换，同时性能也稍微好些</div>

           <div class="title">追踪数据变化以及数据变化的检测</div>
           <pre>
        把一个普通对象传给 Vue 实例作为它的 data 选项，Vue.js 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。
        这是 ES5 特性，不能打补丁实现，这便是为什么 Vue.js 不支持 IE8 及更低版本。
        用户看不到 getter/setters，但是在内部它们让 Vue.js 追踪依赖，在属性被访问和修改时通知变化。一个问题是在浏览器控制台打印数
        据对象时 getter/setter 的格式化不同，使用 vm.$log() 实例方法可以得到更友好的输出。
        模板中每个指令/数据绑定都有一个对应的 watcher 对象，在计算过程中它把属性记录为依赖。之后当依赖的 setter 被调用时，
        会触发 watcher 重新计算 ，也就会导致它的关联指令更新 DOM。

        受 ES5 的限制，Vue.js 不能检测到对象属性的添加或删除。因为 Vue.js 在初始化实例时将属性转为 getter/setter，所以属性必须在
         data 对象上才能让 Vue.js 转换它，才能让它是响应的。例如：
        var data = { a: 1 }
        var vm = new Vue({
          data: data
        })
        // `vm.a` 和 `data.a` 现在是响应的
        vm.b = 2
        // `vm.b` 不是响应的
        data.b = 2
        // `data.b` 不是响应的
        不过，有办法在实例创建之后添加属性并且让它是响应的。
        对于 Vue 实例，可以使用 $set(key, value) 实例方法：
        vm.$set('b', 2)
        // `vm.b` 和 `data.b` 现在是响应的
        对于普通数据对象，可以使用全局方法 Vue.set(object, key, value)：
        Vue.set(data, 'c', 3)
        // `vm.c` 和 `data.c` 现在是响应的   	
           </pre>

           <div class="title">异步队列更新</div>
           <pre>
        Vue.js 默认异步更新 DOM。每当观察到数据变化时，Vue 就开始一个队列，将同一事件循环内所有的数据变化缓存起来。
        如果一个 watcher 被多次触发，只会推入一次到队列中。等到下一次事件循环，Vue 将清空队列，只进行必要的 DOM 更新。
        在内部异步队列优先使用 MutationObserver，如果不支持则使用 setTimeout(fn, 0)。
        例如，设置了 vm.someData = 'new value'，DOM 不会立即更新，而是在下一次事件循环清空队列时更新。我们基本不用关心这个过程，
        但是如果想在 DOM 状态更新后做点什么，这会有帮助。尽管 Vue.js 鼓励开发者沿着数据驱动的思路，避免直接修改 DOM，但是有时
        确实要这么做。为了在数据变化之后等待 Vue.js 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback) 。回调在
        DOM 更新完成后调用。例如：  
        <span><</span><span>div&nbsp;id='example'</span><span>></span>{{msg}}<span><</span>/div<span>></span>
        var vm = new Vue({
          el: '#example',
          data: {
            msg: '123'
          }
        })
        vm.msg = 'new message' // 修改数据
        vm.$el.textContent === 'new message' // false
        Vue.nextTick(function () {
          vm.$el.textContent === 'new message' // true
        })
        vm.$nextTick() 这个实例方法比较方便，因为它不需要全局 Vue，它的回调的 this 自动绑定到当前 Vue 实例：
        Vue.component('example', {
          template: '<span><</span>span<span>></span>{{msg}}<span><</span>/span<span>></span>',
          data: function () {
            return {
              msg: 'not updated'
            }
          },
          methods: {
            updateMessage: function () {
              this.msg = 'updated'
              console.log(this.$el.textContent) // => 'not updated'
              this.$nextTick(function () {
                console.log(this.$el.textContent) // => 'updated'
              })
            }
          }
        })
           </pre>

           <div class="title">计算属性的理解</div>
           <pre>
        你应该注意到 Vue.js 的计算属性不是简单的 getter。计算属性持续追踪它的响应依赖。在计算一个计算属性时，Vue.js 更新它的依赖
        列表并缓存结果，只有当其中一个依赖发生了变化，缓存的结果才无效。因此，只要依赖不发生变化，访问计算属性会直接返回缓存的结果
        而不是调用 getter。之所以要缓存是因为假设我们有一个高耗计算属性 A，它要遍历一个巨型数组并做大量的计算。然后，可能有其它的计
        算属性依赖 A。如果没有缓存，我们将调用 A 的 getter 许多次，超过必要次数。
        由于计算属性被缓存了，在访问它时 getter 不总是被调用。考虑下例：
	        var vm = new Vue({
	          data: {
	            msg: 'hi'
	          },
	          computed: {
	            example: function () {
	              return Date.now() + this.msg
	            }
	          }
	        })
        计算属性 example 只有一个依赖：vm.msg。Date.now() 不是 响应依赖，因为它跟 Vue 的数据观察系统无关。因而在访问vm.example 时
        将发现时间戳不变，除非 vm.msg 变了。
        有时希望 getter 不改变原有的行为，每次访问 vm.example 时都调用 getter。这时可以为指定的计算属性关闭缓存：
	        computed: {
	          example: {
	            cache: false,
	            get: function () {
	              return Date.now() + this.msg
	            }
	          }
	        }
        现在每次访问 vm.example时，时间戳都是新的。但是，只是在JavaScript中访问是这样的；数据绑定仍是依赖驱动的。如果在模块中这样绑
        定计算属性 {{example}}，只有响应依赖发生变化时才更新 DOM。   	
           </pre>

           <div class="title">vue-router常用的东西的记录</div>
           <pre>
        router.beforeEach(function (transition) {
          if (transition.to.path === '/forbidden') {
            transition.abort()
          } else {
            transition.next()
          }
        })
        使用 Promise 和 ES6
        router.beforeEach(function ({ to, next }) {
          if (to.path === '/auth-required') {
            // 返回一个断定会 true 或者 false 的 Promise
            return AuthService.isLoggedIn()
          } else {
            next()
          }
        })
        每个切换钩子函数都会接受一个 transition 对象作为参数:
            transition.to:一个代表将要切换到的路径的路由对象
            transition.next:调用此函数处理切换过程的下一步
            transition.from:一个代表当前路径的路由对象
            transition.abort([reason]):调用此函数来终止或者拒绝此次切换。
            transition.redirect(path):取消当前切换并重定向到另一个路由
           </pre>
           <div class="explain">其实对于不同的写法，transition.to是等于es6下的to的，该对象下有path,params等键</div>

       </div>
  </body>
</html>
