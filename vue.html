<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Blog by limingkang</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <!-- <link rel="stylesheet" href="stylesheets/github-light.css"> -->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="前端开发记录">
    <meta name="keywords" content="gulp,react,node,webpack,redux,require,mysql,mongodb">
  </head>
  <body>
       <div class="big_container">
           <div class="title" style="margin-top:0;">vue.js与其他框架的比较</div>
           <pre>
        Vue 与 Angular的比较：
           1.vue的api比angular简单，易于学习，它允许你自定义组织应用程序的方式，不必任何时候都遵循angular规则，它仅仅是一个视图层，
           所以你可以将它嵌入一个现有页面而不一定要做成一个庞大的单页应用。在配合其他库方面它给了你更大的的空间，但相应，
           你也需要做更多的架构决策。例如，Vue.js 核心默认不包含路由和 Ajax 功能，并且通常假定你在应用中使用了一个模块构建系统
           2.Angular 使用双向绑定，Vue 也支持双向绑定，不过默认为单向绑定，数据从父组件单向传给子组件。在大型应用中使用单向绑定让
           数据流易于理解
           3.Vue.js 有更好的性能，并且非常非常容易优化，因为它不使用脏检查。Angular，当 watcher 越来越多时会变得越来越慢，因为作用域
           内的每一次变化，所有 watcher 都要重新计算。并且，如果一些 watcher 触发另一个更新，脏检查循环（digest cycle）可能要运行多次
           Angular 用户常常要使用深奥的技术，以解决脏检查循环的问题。有时没有简单的办法来优化有大量 watcher 的作用域。Vue.js 则根本
           没有这个问题，因为它使用基于依赖追踪的观察系统并且异步列队更新，所有的数据变化都是独立地触发，除非它们之间有明确的依赖关系
           唯一需要做的优化是在 v-for 上使用 track-by

        vue和react的比较：
           1.React 的渲染建立在 Virtual DOM 上——一种在内存中描述 DOM 树状态的数据结构。当状态发生变化时，React 重新渲染 Virtual DOM
           比较计算之后给真实 DOM 打补丁。Virtual DOM 提供了一个函数式的方法描述视图，这真的很棒。因为它不使用数据观察机制，每次
           更新都会重新渲染整个应用，因此从定义上保证了视图与数据的同步。它也开辟了 JavaScript 同构应用的可能性
           2.Vue.js 不使用 Virtual DOM 而是使用真实 DOM 作为模板，数据绑定到真实节点。Vue.js 的应用环境必须提供 DOM。但是，相对于常
           见的误解——Virtual DOM 让 React 比其它的都快， Vue.js 实际上性能比 React 好，而且几乎不用手工优化。而 React，为了最优化的
           渲染需要处处实现 shouldComponentUpdate 和使用不可变数据结构
           3.在 API 方面，React（或 JSX）的一个问题是，渲染函数常常包含大量的逻辑，最终看着更像是程序片断（实际上就是）而不是界面的
           视觉呈现。对于部分开发者来说，他们可能觉得这是个优点，但对那些像我一样兼顾设计和开发的人来说，模板能让我们更好地在视觉上
           思考设计和 CSS。JSX 和 JavaScript 逻辑的混合干扰了我将代码映射到设计的思维过程。相反，Vue.js 通过在模板中加入一个轻量级
           的 DSL (指令系统)，换来一个依旧直观的模板，且能将逻辑封装进指令和过滤器中
           4.React 的另一个问题是：由于 DOM 更新完全交给 Virtual DOM 管理，当想要自己控制 DOM 时就有点棘手了（虽然理论上可以做到，但
           这样做就本质上违背了 React 的设计思想）。如果应用需要特别的自定义 DOM 操作，特别是复杂时间控制的动画，这个限制就很讨厌。
           在这方面，Vue.js 更灵活
           5.对于大型应用，React 社区已经创造了大量的状态管理方案，例如 Flux/Redux。Vue 本身不解决这个问题（React 内核也是）,但是可以
           轻松地修改状态管理模式，实现一个类似的架构。Vue 有自己的状态管理方案 Vuex，而且 Vue 也可以与 Redux 一起用
           6.React 的开发趋势是将所有东西都放在 JavaScript 中，包括 CSS。已经有许多 CSS-in-JS 方案，但是所有的方案多多少少都有问题
           而且更重要的是，这么做脱离了标准的 CSS 开发经验，并且很难和 CSS 社区的已有工作配合。Vue 的 单文件组件 在把 CSS 封装到组件
           模块的同时仍然允许你使用你喜欢的预处理器

        vue和ember的比较：
           1.Ember 是一个全能框架。它提供大量的约定，一旦你熟悉了它们，开发会很高效。不过，这也意味着学习曲线较高，而且不灵活。在框架
           和库（加上一系列松散耦合的工具）之间权衡选择。后者更自由，但是也要求你做更多的架构决定。也就是说，最好比较 Vue.js 内核和
           Ember 的模板与数据模型层
           2.Vue在普通JavaScript对象上建立响应，提供自动化的计算属性。在Ember中要将所有东西放在Ember对象内，并且手工为计算属性声明依赖
           3.Vue 的模板语法可以用全功能的 JavaScript 表达式，而 Handlebars 的语法和帮助函数语法相比之下非常受限
           4.在性能上，Vue甩开Ember几条街，即使是Ember 2.0最新的Glimmer引擎。Vue 自动批量更新，在性能比较关键时 Ember 要手工管理循环
           </pre>
           <div class="explain">vue.js中文文档地址<a href="http://cn.vuejs.org/guide/installation.html">http://cn.vuejs.org/guide/installation.html</a></div>
           <div class="explain">vue.js中文社区地址<a href="http://forum.vuejs.org/category/10/%E4%B8%AD%E6%96%87">http://forum.vuejs.org/category/10/%E4%B8%AD%E6%96%87</a></div>
       
           <div class="title">实例的生命周期</div>
           <pre>
        Vue 实例在创建时有一系列初始化步骤——例如，它需要建立数据观察，编译模板，创建必要的数据绑定。在此过程中，它也将调用一些生命
        周期钩子，给自定义逻辑提供运行机会。例如 created 钩子在实例创建后调用：
	        var vm = new Vue({
	          data: {
	            a: 1
	          },
	          created: function () {
	            // `this` 指向 vm 实例
	            console.log('a is: ' + this.a)
	          }
	        })
	        // -> "a is: 1"
        也有一些其它的钩子，在实例生命周期的不同阶段调用，如 compiled、 ready 、destroyed。钩子的 this 指向调用它的 Vue 实例。
        Vue.js没有是没有控制器的概念的，组件的自定义逻辑可以分割在这些钩子中
           </pre>
           <div class="explain">具体详细生命周期可查官方文档</div>

           <div class="title">条件渲染v-if和v-show的区别</div>
           <pre>
        在切换 v-if 块时，Vue.js 有一个局部编译/卸载过程，因为 v-if 之中的模板也可能包括数据绑定或子组件。v-if 是真实的条件渲染，因为
        它会确保条件块在切换当中合适地销毁与重建条件块内的事件监听器和子组件。
        v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——在条件第一次变为真时才开始局部编译（编译会被缓存起来）。
        相比之下，v-show 简单得多——元素始终被编译并保留，只是简单地基于 CSS 切换。
        一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能
        改变v-if 较好。
           </pre>

           <div class="title">数组变动检测</div>
           <pre>
        1.Vue.js 包装了被观察数组的变异方法，故它们能触发视图更新。被包装的方法有：
        	push()、pop()、shift()、unshift()、splice()、sort()、reverse()
        	你可以打开浏览器的控制台，用这些方法修改上例的 items 数组。例如：example1.items.push({ message: 'Baz' })   	
        
        2.变异方法，如名字所示，修改了原始数组。相比之下，也有非变异方法，如 filter(), concat() 和 slice()，不会修改原始数组而是返回
        一个新数组。在使用非变异方法时，可以直接用新数组替换旧数组：
			example1.items = example1.items.filter(function (item) {
			  return item.message.match(/Foo/)
			})
	可能你觉得这将导致 Vue.js 弃用已有 DOM 并重新渲染整个列表——幸运的是并非如此。 Vue.js 实现了一些启发算法，以最大化复用 DOM 元素
	因而用另一个数组替换数组是一个非常高效的操作

	3.有时需要用全新对象（例如通过 API 调用创建的对象）替换数组。因为 v-for 默认通过数据对象的特征来决定对已有作用域和 DOM 元素的
	复用程度，这可能导致重新渲染整个列表。但是，如果每个对象都有一个唯一 ID 的属性，便可以使用 track-by 特性给 Vue.js 一个提示，
	Vue.js 因而能尽可能地复用已有实例。例如，假定数据为：
		{
		  items: [
		    { _uid: '88f869d', ... },
		    { _uid: '7496c10', ... }
		  ]
		}
	然后可以这样给出提示：
	<textarea>
		<div v-for="item in items" track-by="_uid"><!-- content --></div>
	</textarea>
    	然后在替换数组 items 时，如果 Vue.js 遇到一个包含 _uid: '88f869d' 的新对象，这个对象的_uid和上面的一样，只是其他值不一样,
    	它知道它可以复用这个已有对象的作用域与DOM 元素。
           
        4.因为 JavaScript 的限制，Vue.js 不能检测到下面数组变化：
		直接用索引设置元素，如 vm.items[0] = {}；
		修改数据的长度，如 vm.items.length = 0。
	为了解决问题 (1)，Vue.js 扩展了观察数组，为它添加了一个 $set() 方法：
		// 与 `example1.items[0] = ...` 相同，但是能触发视图更新
		example1.items.$set(0, { childMsg: 'Changed!'})
		至于问题 (2)，只需用一个空数组替换 items。
	除了 $set()， Vue.js 也为观察数组添加了 $remove() 方法，用于从目标数组中查找并删除元素，在内部它调用 splice().不必这样：
		var index = this.items.indexOf(item)
		if (index !== -1) {
		  this.items.splice(index, 1)
		}
	只用这样：
		this.items.$remove(item)
	使用 Object.freeze()在遍历一个数组时，如果数组元素是对象并且对象用 Object.freeze() 冻结，你需要明确指定 track-by。在这
	种情况下如果 Vue.js 不能自动追踪对象，将给出一条警告
           </pre>

           <div class="title">事件处理</div>
           <pre>
        1.事件处理器限制为一个语句，有时也需要在内联语句处理器中访问原生 DOM 事件。可以用特殊变量 $event 把它传入方法：
        <textarea>
        	<button v-on:click="say('hello!', $event)">Submit</button>
        </textarea> 
        methods: {
          say: function (msg, event) {
            // 现在我们可以访问原生事件对象
            event.preventDefault()
          }
        }
        2.在事件处理器中经常需要调用 event.preventDefault() 或 event.stopPropagation()。尽管我们在方法内可以轻松做到，不过让方法
        是纯粹的数据逻辑而不处理 DOM 事件细节会更好。为了解决这个问题，Vue.js 为 v-on 提供两个 事件修饰符：.prevent 与 .stop 
        <textarea style="height:720px;">
        	<!-- 阻止单击事件冒泡 -->
        	<a v-on:click.stop="doThis"></a>

        	<!-- 提交事件不再重载页面 -->
        	<form v-on:submit.prevent="onSubmit"></form>

        	<!-- 修饰符可以串联 -->
        	<a v-on:click.stop.prevent="doThat">

        	<!-- 只有修饰符 -->
        	<form v-on:submit.prevent></form>

        	1.0.16 添加了两个额外的修饰符：
        	<!-- 添加事件侦听器时使用 capture 模式 -->
        	<div v-on:click.capture="doThis">...</div>

        	<!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 -->
        	<div v-on:click.self="doThat">...</div>

        	全部的按键别名：enter,tab,delete,esc,space,up,down,left,right
        	<!-- 只有在 keyCode 是 13 时调用 vm.submit() -->
        	<input v-on:keyup.13="submit">

        	<!-- 同上 -->
        	<input v-on:keyup.enter="submit">

        	<!-- 缩写语法 -->
        	<input @keyup.enter="submit">

        	1.0.17+： 可以自定义按键别名：可以使用 @keyup.f1
        	Vue.directive('on').keyCodes.f1 = 112
        </textarea> 	
           </pre>

           <div class="title">表单控件绑定</div>
           <pre>
        对于单选按钮，勾选框及选择框选项，v-model 绑定的 value 通常是静态字符串（对于勾选框是逻辑值）：
        <textarea style="height:250px;">
        <!-- 当选中时，`picked` 为字符串 "a" -->
        <input type="radio" v-model="picked" value="a">

        <!-- `toggle` 为 true 或 false -->
        <input type="checkbox" v-model="toggle">

        <!-- 当选中时，`selected` 为字符串 "abc" -->
        <select v-model="selected">
          <option value="abc">ABC</option>
        </select>	
        </textarea>
        但是有时我们想绑定 value 到 Vue 实例的一个动态属性上，这时可以用 v-bind 实现，并且这个属性的值可以不是字符串
        <textarea style="height:316px;">
        	<input
        	  type="checkbox"
        	  v-model="toggle"
        	  v-bind:true-value="a"
        	  v-bind:false-value="b">
        	// 当选中时
        	vm.toggle === vm.a
        	// 当没有选中时
        	vm.toggle === vm.b

        	<input type="radio" v-model="pick" v-bind:value="a">
        	// 当选中时
        	vm.pick === vm.a
        </textarea>

        在默认情况下，v-model 在input 事件中同步输入框值与数据，可以添加一个特性 lazy，从而改到在 change 事件中同步：
        <textarea style="height:66px;">
        	<!-- 在 "change" 而不是 "input" 事件中更新 -->
			<input v-model="msg" lazy>
        </textarea>
        如果想自动将用户的输入转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个特性 number：
        <textarea>
        <input v-model="age" number>
        </textarea>
        debounce 设置一个最小的延时，在每次敲击之后延时同步输入框的值与数据。如果每次更新都要进行高耗操作（例如在输入提示中 Ajax 请求）
        注意 debounce 参数不会延迟 input 事件：它延迟“写入”底层数据。因此在使用 debounce 时应当用 vm.$watch() 响应数据的变化。
        若想延迟 DOM 事件，应当使用 debounce 过滤器。
        <textarea>
        	<input v-model="msg" debounce="500">
        </textarea>
           </pre>

           <div class="title">过渡动画</div>
           <pre>
        通过 Vue.js 的过渡系统，可以在元素从 DOM 中插入或移除时自动应用过渡效果。Vue.js 会在适当的时机为你触发 CSS 过渡或动画，你也
        可以提供相应的 JavaScript 钩子函数在过渡过程中执行自定义的 DOM 操作。为了应用过渡效果，需要在目标元素上使用 transition 特性：
        <textarea>
        	<div v-if="show" transition="my-transition"></div>
        </textarea>
        transition 特性可以与下面资源一起用：
           v-if
           v-show
           v-for （只在插入和删除时触发，使用 vue-animated-list 插件）
           动态组件 （介绍见组件）
           在组件的根节点上，并且被 Vue 实例 DOM 方法（如 vm.$appendTo(el)）触发。
        当插入或删除带有过渡的元素时，Vue 将：
           1.尝试以 ID "my-transition" 查找 JavaScript 过渡钩子对象——通过 Vue.transition(id, hooks) 或 transitions 选项注册。
           如果找到了，将在过渡的不同阶段调用相应的钩子。
           2.自动嗅探目标元素是否有 CSS 过渡或动画，并在合适时添加/删除 CSS 类名。
           3.如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作（插入/删除）在下一帧中立即执行。
           </pre>

           <div class="title">渐进过渡</div>
           <pre>
        transition 与 v-for 一起用时可以创建渐近过渡。给过渡元素添加一个特性 stagger, enter-stagger 或 leave-stagger：
        以下就是为每个项目增加一个100毫秒的延时
        <textarea>
        	<div v-for="item in list" transition="stagger" stagger="100"></div>
        </textarea>

        或者，提供一个钩子 stagger, enter-stagger 或 leave-stagger，以更好的控制：
        Vue.transition('stagger', {
          stagger: function (index) {
            // 每个过渡项目增加 50ms 延时
            // 但是最大延时限制为 300ms
            return Math.min(300, index * 50)
          }
        })
           </pre>

           <div class="title">模板解析</div>
           <pre>
        Vue 的模板是 DOM 模板，使用浏览器原生的解析器而不是自己实现一个。相比字符串模板，DOM 模板有一些好处，但是也有问题，它必须是
        有效的 HTML 片段。一些 HTML 元素对什么元素可以放在它里面有限制。常见的限制：
	        a 不能包含其它的交互元素（如按钮，链接）
	        ul 和 ol 只能直接包含 li
	        select 只能包含 option 和 optgroup
	        table 只能直接包含 thead, tbody, tfoot, tr, caption, col, colgroup
	        tr 只能直接包含 th 和 td
        在实际中，这些限制会导致意外的结果。尽管在简单的情况下它可能可以工作，但是你不能依赖自定义组件在浏览器验证之前的展开结果 
        另一个结果是，自定义标签 不能用在 ul, select, table 等对内部元素有限制的标签内。放在这些元素内部的自定义标签将被提到元素的外面
        因而渲染不正确。例如：template标签 不能用在 table 内，这时应使用 tbody标签，table 可以有多个 tbody，从而可以循环了
        <textarea style="height:160px;">
        	<table>
        	  <tbody v-for="item in items">
        	    <tr>Even row</tr>
        	    <tr>Odd row</tr>
        	  </tbody>
        	</table>
        </textarea>	
           </pre>

           <div class="title">prop绑定类型</div>
           <pre>
        prop 默认是单向绑定：当父组件的属性变化时，将传导给子组件，但是反过来不会。这是为了防止子组件无意修改了父组件的状态——这会让
        应用的数据流难以理解。不过，也可以使用 .sync 或 .once 绑定修饰符显式地强制双向或单次绑定
        <textarea style="height:200px;">
        	<!-- 默认为单向绑定 -->
        	<child :msg="parentMsg"></child>

        	<!-- 双向绑定 -->
        	<child :msg.sync="parentMsg"></child>

        	<!-- 单次绑定 -->
        	<child :msg.once="parentMsg"></child>
        </textarea>   	
           </pre>
           <div class="explain">双向绑定会把子组件的 msg 属性同步回父组件的 parentMsg 属性。单次绑定在建立之后不会同步之后的变化,注意如果 prop 是一个对象或数组，是按引用传递。在子组件内修改它会影响父组件的状态，不管是使用哪种绑定类型</div>

           <div class="title">prop验证</div>
           <pre>
        组件可以为 props 指定验证要求。当组件给其他人使用时这很有用，因为这些验证要求构成了组件的 API，确保其他人正确地使用组件。
        此时 props 的值是一个对象，包含验证要求：
            Vue.component('example', {
              props: {
                // 基础类型检测 （`null` 意思是任何类型都可以）
                propA: Number,
                // 多种类型 (1.0.21+)
                propM: [String, Number],
                // 必需且是字符串
                propB: {
                  type: String,
                  required: true
                },
                // 数字，有默认值
                propC: {
                  type: Number,
                  default: 100
                },
                // 对象/数组的默认值应当由一个函数返回
                propD: {
                  type: Object,
                  default: function () {
                    return { msg: 'hello' }
                  }
                },
                // 指定这个 prop 为双向绑定
                // 如果绑定类型不对将抛出一条警告
                propE: {
                  twoWay: true
                },
                // 自定义验证函数
                propF: {
                  validator: function (value) {
                    return value > 10
                  }
                },
                // 转换函数（1.0.12 新增）
                // 在设置值之前转换值
                propG: {
                  coerce: function (val) {
                    return val + '' // 将值转换为字符串
                  }
                },
                propH: {
                  coerce: function (val) {
                    return JSON.parse(val) // 将 JSON 字符串转换为对象
                  }
                }
              }
            })
           </pre>
           <div class="explain">当 prop 验证失败了，Vue 将拒绝在子组件上设置此值，如果使用的是开发版本会抛出一条警告</div>

           <div class="title">自定义事件</div>
           <pre>
        Vue 实例实现了一个自定义事件接口，用于在组件树中通信。这个事件系统独立于原生 DOM 事件，用法也不同。
        不同于 DOM 事件，Vue 事件在冒泡过程中第一次触发回调之后自动停止冒泡，除非回调明确返回 true
        每个 Vue 实例都是一个事件触发器：
	        使用 $on() 监听事件；
	        使用 $emit() 在它上面触发事件；
	        使用 $dispatch() 派发事件，事件沿着父链冒泡；
	        使用 $broadcast() 广播事件，事件向下传导给所有的后代。

	    简单例子：
	    <textarea style="height:270px;">
	    	<!-- 子组件模板 -->
	    	<template id="child-template">
	    	  <input v-model="msg">
	    	  <button v-on:click="notify">Dispatch Event</button>
	    	</template>

	    	<!-- 父组件模板 -->
	    	<div id="events-example">
	    	  <p>Messages: {{ messages | json }}</p>
	    	  <child></child>第二个方法这里改为<child v-on:child-msg="handle"></child>
	    	</div>
	    </textarea>
	    // 注册子组件
	    // 将当前消息派发出去
	    Vue.component('child', {
	      template: '#child-template',
	      data: function () {
	        return { msg: 'hello' }
	      },
	      methods: {
	        notify: function () {
	          if (this.msg.trim()) {
	            this.$dispatch('child-msg', this.msg)
	            this.msg = ''
	          }
	        }
	      }
	    })
	    // 初始化父组件
	    // 将收到消息时将事件推入一个数组
	    var parent = new Vue({
	      el: '#events-example',
	      data: {
	        messages: []
	      },
	      // 在创建实例时 `events` 选项简单地调用 `$on`
	      events: {
	        'child-msg': function (msg) {
	          // 事件回调内的 `this` 自动绑定到注册它的实例上
	          this.messages.push(msg)
	        }
	      }
	    })
	    或者下面这个更加合理：
	    // 注册子组件
	    // 将当前消息派发出去
	    Vue.component('child', {
	      template: '#child-template',
	      data: function () {
	        return { msg: 'hello' }
	      },
	      methods: {
	        notify: function () {
	          if (this.msg.trim()) {
	            this.$dispatch('child-msg', this.msg)
	            this.msg = ''
	          }
	        }
	      }
	    })
	    // 初始化父组件
	    // 将收到消息时将事件推入一个数组
	    var parent = new Vue({
	      el: '#events-example',
	      data: {
	        messages: []
	      },
	      // 在创建实例时 `events` 选项简单地调用 `$on`
	      methods: {
	        'handle': function (msg) {
	          // 事件回调内的 `this` 自动绑定到注册它的实例上
	          this.messages.push(msg)
	        }
	      }
	    })
           </pre>
           <div class="explain">注意events和methods的区别，当你用events选项的时候实际上是在监听里面的事件，一旦有人分发了这个事件就会触发该函数</div>

           <div class="title">编写可复用的组件</div>
           <pre>
        不能传递数据给组件，因为组件的作用域是孤立的。为了传递数据给组件，应当使用 props，在编写组件时，记住是否要复用组件有好处。一次
        性组件跟其它组件紧密耦合没关系，但是可复用组件应当定义一个清晰的公开接口
        Vue.js 组件 API 来自三部分——prop，事件和 slot：   
        	prop 允许外部环境传递数据给组件；
        	事件 允许组件触发外部环境的 action；
        	slot 允许外部环境插入内容到组件的视图结构内。
        <textarea style="height:220px;">
        	<my-component
        	  :foo="baz"
        	  :bar="qux"
        	  @event-a="doThis"
        	  @event-b="doThat">
        	  <!-- content -->
        	  <img slot="icon" src="...">
        	  <p slot="main-text">Hello!</p>
        	</my-component>
        </textarea>	
           </pre>
           <div class="explain"></div>

           <div class="title"></div>
           <pre>
           	
           </pre>
           <div class="explain"></div>

           <div class="title"></div>
           <pre>
           	
           </pre>
           <div class="explain"></div>

           <div class="title"></div>
           <pre>
           	
           </pre>
           <div class="explain"></div>

           <div class="title"></div>
           <pre>
           	
           </pre>
           <div class="explain"></div>

           <div class="title"></div>
           <pre>
           	
           </pre>
           <div class="explain"></div>

           <div class="title"></div>
           <pre>
           	
           </pre>
           <div class="explain"></div>
       </div>
  </body>
</html>
