<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Blog by limingkang</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <!-- <link rel="stylesheet" href="stylesheets/github-light.css"> -->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="前端开发记录">
    <meta name="keywords" content="gulp,react,node,webpack,vue">
  </head>
  <body>
       <div class="big_container">
           <div class="title" style="margin-top:0;">vue.js初识</div>
           <pre>
        Vue 与 Angular的比较：
           1.vue的api比angular简单，易于学习，它允许你自定义组织应用程序的方式，不必任何时候都遵循angular规则，它仅仅是一个视图层，
           所以你可以将它嵌入一个现有页面而不一定要做成一个庞大的单页应用。在配合其他库方面它给了你更大的的空间，但相应，
           你也需要做更多的架构决策。例如，Vue.js 核心默认不包含路由和 Ajax 功能，并且通常假定你在应用中使用了一个模块构建系统
           2.Angular 使用双向绑定，Vue 也支持双向绑定，不过默认为单向绑定，数据从父组件单向传给子组件。在大型应用中使用单向绑定让
           数据流易于理解
           3.Vue.js 有更好的性能，并且非常非常容易优化，因为它不使用脏检查。Angular，当 watcher 越来越多时会变得越来越慢，因为作用域
           内的每一次变化，所有 watcher 都要重新计算。并且，如果一些 watcher 触发另一个更新，脏检查循环（digest cycle）可能要运行多次
           Angular 用户常常要使用深奥的技术，以解决脏检查循环的问题。有时没有简单的办法来优化有大量 watcher 的作用域。Vue.js 则根本
           没有这个问题，因为它使用基于依赖追踪的观察系统并且异步列队更新，所有的数据变化都是独立地触发，除非它们之间有明确的依赖关系

        vue和react的比较：
          1.React 和 Vue 有许多相似之处，它们都有：
              使用 Virtual DOM
              提供了响应式（Reactive）和组件化（Composable）的视图组件。
              将注意力集中保持在核心库，伴随于此，有配套的路由和负责处理全局状态管理的库。
              vuex也是完全借鉴redux的思想
          2.相比于jsx语法，vue的模板编写语法不仅开发人员更容易编写代码，设计人员和开发人员也可以更容易的分析代码和贡献代码，虽然vue也
          支持jsx语法渲染但是并不推荐使用，而且Vue拥抱HTML，而不是用JavaScript去重塑它。在模板内，Vue 也允许你用预处理器比如Jade等
          3.ReactNative 能使你用相同的组件模型编写有本地渲染能力的 APP（IOS 和 Android）。能同时跨多平台开发，对开发者是非常棒的。
          相应地，Vue 和 Weex 会进行官方合作，Weex 是阿里的跨平台用户界面开发框架，Weex 的 JavaScript 框架运行时用的就是 Vue。这意
          味着在 Weex 的帮助下，你使用 Vue 语法开发的组件不仅仅可以运行在浏览器端，还能被用于开发 IOS 和 Android 上的原生应用

        vue和ember的比较：
           1.Ember 是一个全能框架。它提供大量的约定，一旦你熟悉了它们，开发会很高效。不过，这也意味着学习曲线较高，而且不灵活。在框架
           和库（加上一系列松散耦合的工具）之间权衡选择。后者更自由，但是也要求你做更多的架构决定。也就是说，最好比较 Vue.js 内核和
           Ember 的模板与数据模型层
           2.Vue在普通JavaScript对象上建立响应，提供自动化的计算属性。在Ember中要将所有东西放在Ember对象内，并且手工为计算属性声明依赖
           3.Vue 的模板语法可以用全功能的 JavaScript 表达式，而 Handlebars 的语法和帮助函数语法相比之下非常受限
           4.在性能上，Vue甩开Ember几条街，即使是Ember 2.0最新的Glimmer引擎。Vue 自动批量更新，在性能比较关键时 Ember 要手工管理循环
          
        vue的服务器端渲染(SSR):
           如果你只是用服务端渲染来改善一个少数的营销页面（如 首页，关于，联系 等等）的SEO，那你可以用预渲染替换。预渲染不像服务器
           渲染那样即时编译HTML,预渲染只是在构建时为了特定的路由生成特定的几个静态页面。其优势是预渲染的设置更加简单，可以保持前端
           是一个完整的静态站。node有vue-server-renderer这个模块可以做到，正如react的React.renderToString方法，之所以可以做到是因
           为其实vue的底层也采用了virtual dom，而且vuex也借鉴了redux的思想。

        Vue作为一个没有入侵性的框架并不限制你使用ajax框架,你可以自己封装一套或者使用jquery（注意vue-resource官方已经不再跟新推荐）
        官方推荐使用axios.js,还有一个fetch.js也很好用，感觉会是未来的一个趋势。
           </pre>
           <div class="explain">vue.js中文文档地址<a href="http://cn.vuejs.org/guide/installation.html">http://cn.vuejs.org/guide/installation.html</a></div>
           <div class="explain">vue-router中文文档<a href="http://router.vuejs.org/zh-cn/">http://router.vuejs.org/zh-cn/</a></div>
           <div class="explain">Nuxt.js开发服务端渲染<a href="https://zh.nuxtjs.org/guide">https://zh.nuxtjs.org/guide</a></div>
           <div class="explain">vue-loader结合webpack的配置详解<a href="https://vue-loader.vuejs.org/zh-cn/start/spec.html">https://vue-loader.vuejs.org/zh-cn/start/spec.html</a></div>
       	   <div class="explian">对于sublime先下插件Vuejs Snippets和Vue Syntax Highlight，这样便于.vue文件的开发,具体项目应用可去github中查看vue-webpack-starter这个小应用</div>

           <div class="title">过渡效果的理解</div>
           <pre>
        Vue 提供了 transition 的封装组件，在使用v-if、v-show或者动态组件的时候，可以给任何元素和组件添加 entering/leaving 过渡
            <textarea style="height:376px;" readonly='readonly'>
                .fade-enter-active, .fade-leave-active {
                  transition: opacity .5s
                }
                .fade-enter, .fade-leave-active {
                  opacity: 0
                }
                <transition name="fade" appear mode="out-in">
                    <div v-if="show" key="one">
                        <p>hello</p>
                        <p>hello</p>
                    </div>
                    <div v-else key="two">
                       <p>no</p>
                       <p>no</p>
                    </div>
                </transition>
            </textarea>
        1.正如上面所示，transition标签只能对单个元素或者组件做动画，上面无论是用v-if还是v-show都会触发动画但是要注意使用v-show的时候
        只能有这一个节点里面不可以再写其他v-show了，但是v-else，v-if却可以写多个，其中动画的出现我们可以根据name名字来加上相应类
        名以实现动画
        2.当然我们也可以使用js钩子来完成相应动画，注意当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须
        的.否则，它们会被同步调用，过渡会立即完成。对于仅使用 JavaScript 过渡的元素添加 v-bind:css="false"，Vue 会跳过CSS的检测
        这也可以避免过渡过程中 CSS 的影响
        3.添加appear属性可以使其在页面一进来的时候就运行一次上面设置的动画，这就是所谓的初始渲染
        4.当使用多个v-if时，一定要加上不同的key值，否则vue为了效率只是把里面的内容换了所以就没了动画，但是加上之后的话就是切换两
        组内容节点了，就可以设置动画了，可以加上mode属性,默认情况下是两个节点动画同时开始
        5.多个组件的过渡很简单很多 - 我们不需要使用 key 特性。相反，我们只需要使用动态组件就是使用component标签和is特性去绑定不同
        的组件
        

        对于列表的位移过度，就是通过v-for循环出来时候节点的动画的设置，transition-group 组件还有一个特殊之处。不仅可以进入和离
        开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。像之前的类名一样
        可以通过 name 属性来自定义前缀，也可以通过 move-class 属性手动设置其内部的实现，Vue 使用了一个叫 FLIP 简单的动画队列。
        注意v-mode是用来设置定位变化时候的动画的如.list-complete-move{transition: transform 2s;}你不设置他也有默认的效果，
        动画的效果还是通过上面那些属性名加样式来设置，有时候如果没动画的话。例如离开的时候没有就可以在其离开的样式上面加上position
        ：absolute;或者其他改变其定位方式的属性，就会也有动画了


        无论是单节点的动画还是多节点动画还是列表动画还是js动画只要在其动画上加上appear属性，就可以实现页面一打开就运行一次动画的效果
           
        以下是使用zepto动画写的一个渐进过度的效果总是感觉好生硬，使用velocity动画框架会好很多：
        <textarea style="height:400px;">
          <div id="staggered-list-demo">
            <input v-model="query">
            <transition-group appear
              name="staggered-fade"
              tag="ul"
              v-bind:css="false"
              v-on:before-enter="beforeEnter"
              v-on:enter="enter"
              v-on:leave="leave"
            >
              <li
                v-for="(item, index) in computedList"
                v-bind:key="item.msg"
                v-bind:data-index="index"
              >{{ item.msg }}</li>
            </transition-group>
          </div>
        </textarea>
        new Vue({
          el: '#staggered-list-demo',
          data: {
            query: '',
            list: [
              { msg: 'Bruce Lee' },
              { msg: 'Jackie Chan' },
              { msg: 'Chuck Norris' },
              { msg: 'Jet Li' },
              { msg: 'Kung Fury' }
            ]
          },
          computed: {
            computedList: function () {
              var vm = this
              return this.list.filter(function (item) {
                return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1
              })
            }
          },
          methods: {
            beforeEnter: function (el) {
              el.style.opacity = 0
              el.style.height = 0
            },
            enter: function (el, done) {
              var delay = el.dataset.index * 150;
              var self=this;
              setTimeout(function () {
                $(el).animate({
                    opacity: 1, 
                    height: '1.6em'
                },{ duration: 200, complete: done });
              }, delay)
            },
            leave: function (el, done) {
              var delay = el.dataset.index * 150
              setTimeout(function () {
                $(el).animate({
                    opacity: 0, 
                    height: 0
                },{ duration: 100, complete: done });

              }, delay)
            }
          }
        })
           </pre>

           <div class="title">模板解析</div>
           <pre>
        Vue 的模板是 DOM 模板，使用浏览器原生的解析器而不是自己实现一个。相比字符串模板，DOM 模板有一些好处，但是也有问题，它必须是
        有效的 HTML 片段。一些 HTML 元素对什么元素可以放在它里面有限制。常见的限制：
	        a 不能包含其它的交互元素（如按钮，链接）
	        ul 和 ol 只能直接包含 li
	        select 只能包含 option 和 optgroup
	        table 只能直接包含 thead, tbody, tfoot, tr, caption, col, colgroup
	        tr 只能直接包含 th 和 td
        在实际中，这些限制会导致意外的结果。尽管在简单的情况下它可能可以工作，但是你不能依赖自定义组件在浏览器验证之前的展开结果 
        另一个结果是，自定义标签 不能用在 ul, select, table 等对内部元素有限制的标签内。放在这些元素内部的自定义标签将被提到元素的外面
        因而渲染不正确。例如：template标签 不能用在 table 内，这时应使用 tbody标签，table 可以有多个 tbody，从而可以循环了
        <textarea style="height:160px;" readonly='readonly'>
        	<table>
        	  <tbody v-for="item in items">
        	    <tr>Even row</tr>
        	    <tr>Odd row</tr>
        	  </tbody>
        	</table>
        </textarea>	
           </pre>

           <div class="title">对特殊元素key的理解</div>
           <pre>
        1.key 的特殊属性主要用在 Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用key，Vue会使用一种最大限度减少动态元素并且
        尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素。
        2.有相同父元素的子元素必须有独特的key。重复的key会造成渲染错误。 尤其是在使用v-for的时候如果不给key属性的话不仅页面渲染不出
        来连动画都显示不出来了
        3.它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用:
           完整地触发组件的生命周期钩子
           触发过渡
           <textarea style="height:110px;" readonly='readonly'>
             <transition>
               <span :key="text">{{ text }}</span>
             </transition>
             当 text 发生改变时，<span> 会随时被更新，因此会触发过渡。
           </textarea>
           </pre>
 
           <div class="title">编写可复用的组件</div>
           <pre>
        不能传递数据给组件，因为组件的作用域是孤立的。为了传递数据给组件，应当使用 props，在编写组件时，记住是否要复用组件有好处。一次
        性组件跟其它组件紧密耦合没关系，但是可复用组件应当定义一个清晰的公开接口
        Vue.js 组件 API 来自三部分——prop，事件和 slot：   
        	prop 允许外部环境传递数据给组件；
        	事件 允许组件触发外部环境的 action；
        	slot 允许外部环境插入内容到组件的视图结构内。
        <textarea style="height:220px;" readonly='readonly'>
        	<my-component
        	  :foo="baz"
        	  :bar="qux"
        	  @event-a="doThis"
        	  @event-b="doThat">
        	  <!-- content -->
        	  <img slot="icon" src="...">
        	  <p slot="main-text">Hello!</p>
        	</my-component>
        </textarea>	
           </pre>

           <div class="title">追踪数据变化以及数据变化的检测</div>
           <pre>
        把一个普通对象传给 Vue 实例作为它的 data 选项，Vue.js 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。
        这是 ES5 特性，不能打补丁实现，这便是为什么 Vue.js 不支持 IE8 及更低版本。
        用户看不到 getter/setters，但是在内部它们让 Vue.js 追踪依赖，在属性被访问和修改时通知变化。一个问题是在浏览器控制台打印数
        据对象时 getter/setter 的格式化不同，使用 vm.$log() 实例方法可以得到更友好的输出。
        模板中每个指令/数据绑定都有一个对应的 watcher 对象，在计算过程中它把属性记录为依赖。之后当依赖的 setter 被调用时，
        会触发 watcher 重新计算 ，也就会导致它的关联指令更新 DOM。

        受 ES5 的限制，Vue.js 不能检测到对象属性的添加或删除。因为 Vue.js 在初始化实例时将属性转为 getter/setter，所以属性必须在
         data 对象上才能让 Vue.js 转换它，才能让它是响应的。例如：
        var data = { a: 1 }
        var vm = new Vue({
          data: data
        })
        // `vm.a` 和 `data.a` 现在是响应的
        vm.b = 2
        // `vm.b` 不是响应的
        data.b = 2
        // `data.b` 不是响应的
        不过，有办法在实例创建之后添加属性并且让它是响应的。
        对于 Vue 实例，可以使用 $set(key, value) 实例方法：
        vm.$set('b', 2)
        // `vm.b` 和 `data.b` 现在是响应的
        对于普通数据对象，可以使用全局方法 Vue.set(object, key, value)：
        Vue.set(data, 'c', 3)
        // `vm.c` 和 `data.c` 现在是响应的   	
           </pre>

           <div class="title">异步队列更新</div>
           <pre>
        Vue.js 默认异步更新 DOM。每当观察到数据变化时，Vue 就开始一个队列，将同一事件循环内所有的数据变化缓存起来。
        如果一个 watcher 被多次触发，只会推入一次到队列中。等到下一次事件循环，Vue 将清空队列，只进行必要的 DOM 更新。
        在内部异步队列优先使用 MutationObserver，如果不支持则使用 setTimeout(fn, 0)。
        例如，设置了 vm.someData = 'new value'，DOM 不会立即更新，而是在下一次事件循环清空队列时更新。我们基本不用关心这个过程，
        但是如果想在 DOM 状态更新后做点什么，这会有帮助。尽管 Vue.js 鼓励开发者沿着数据驱动的思路，避免直接修改 DOM，但是有时
        确实要这么做。为了在数据变化之后等待 Vue.js 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback) 。回调在
        DOM 更新完成后调用。例如：  
        <span><</span><span>div&nbsp;id='example'</span><span>></span>{{msg}}<span><</span>/div<span>></span>
        var vm = new Vue({
          el: '#example',
          data: {
            msg: '123'
          }
        })
        vm.msg = 'new message' // 修改数据
        vm.$el.textContent === 'new message' // false
        Vue.nextTick(function () {
          vm.$el.textContent === 'new message' // true
        })
        vm.$nextTick() 这个实例方法比较方便，因为它不需要全局 Vue，它的回调的 this 自动绑定到当前 Vue 实例：
        Vue.component('example', {
          template: '<span><</span>span<span>></span>{{msg}}<span><</span>/span<span>></span>',
          data: function () {
            return {
              msg: 'not updated'
            }
          },
          methods: {
            updateMessage: function () {
              this.msg = 'updated'
              console.log(this.$el.textContent) // => 'not updated'
              this.$nextTick(function () {
                console.log(this.$el.textContent) // => 'updated'
              })
            }
          }
        })
           </pre>

           <div class="title">计算属性的理解</div>
           <pre>
        你应该注意到 Vue.js 的计算属性不是简单的 getter。计算属性持续追踪它的响应依赖。在计算一个计算属性时，Vue.js 更新它的依赖
        列表并缓存结果，只有当其中一个依赖发生了变化，缓存的结果才无效。因此，只要依赖不发生变化，访问计算属性会直接返回缓存的结果
        而不是调用 getter。之所以要缓存是因为假设我们有一个高耗计算属性 A，它要遍历一个巨型数组并做大量的计算。然后，可能有其它的计
        算属性依赖 A。如果没有缓存，我们将调用 A 的 getter 许多次，超过必要次数。
        由于计算属性被缓存了，在访问它时 getter 不总是被调用。考虑下例：
	        var vm = new Vue({
	          data: {
	            msg: 'hi'
	          },
	          computed: {
	            example: function () {
	              return Date.now() + this.msg
	            }
	          }
	        })
        计算属性 example 只有一个依赖：vm.msg。Date.now() 不是 响应依赖，因为它跟 Vue 的数据观察系统无关。因而在访问vm.example 时
        将发现时间戳不变，除非 vm.msg 变了。
        有时希望 getter 不改变原有的行为，每次访问 vm.example 时都调用 getter。这时可以为指定的计算属性关闭缓存：
	        computed: {
	          example: {
	            cache: false,
	            get: function () {
	              return Date.now() + this.msg
	            }
	          }
	        }
        现在每次访问 vm.example时，时间戳都是新的。但是，只是在JavaScript中访问是这样的；数据绑定仍是依赖驱动的。如果在模块中这样绑
        定计算属性 {{example}}，只有响应依赖发生变化时才更新 DOM。   	
           </pre>
           <div class="explain">所有的计算属性是不能传参数的，只能直接写这个方法,Vue 2.x 中，过滤器只能在 mustache 绑定中使用。
           为了在指令绑定中实现同样的行为，你应该使用计算属性</div>

           <div class="title">vue-router</div>
           <pre>
        router.beforeEach(function (transition) {
          if (transition.to.path === '/forbidden') {
            transition.abort()
          } else {
            transition.next()
          }
        })
        使用 Promise 和 ES6
        router.beforeEach(function ({ to, next }) {
          if (to.path === '/auth-required') {
            // 返回一个断定会 true 或者 false 的 Promise
            return AuthService.isLoggedIn()
          } else {
            next()
          }
        })
        每个切换钩子函数都会接受一个 transition 对象作为参数:
            transition.to:一个代表将要切换到的路径的路由对象
            transition.next:调用此函数处理切换过程的下一步
            transition.from:一个代表当前路径的路由对象
            transition.abort([reason]):调用此函数来终止或者拒绝此次切换。
            transition.redirect(path):取消当前切换并重定向到另一个路由
           </pre>
           <div class="explain">其实对于不同的写法，transition.to是等于es6下的to的，该对象下有path,params等键</div>

       </div>
  </body>
</html>
