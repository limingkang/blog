<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="chrome=1">
        <title>Blog by limingkang</title>
        <link rel="stylesheet" href="stylesheets/styles.css">
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="description" content="前端开发记录">
        <meta name="keywords" content="angular">
    </head>
    <body>
        <div class="big_container">
            <div class="title">angular介绍</div>
            <pre>
        1.由于angular1的问题非常多，所以本人并不看好其发展，但是新出来的angular可以说其设计上性能上都有了巨大的飞跃，还是值得
        一学的。不得不说Angular相对于Vue的优势在Vue2.0之后已经削弱很多了。比如SSR（Vue2已经原生支持）和全栈式框架（官方推荐
        Vuex+Vue-Router），native端也有阿里巴巴的weex
        2. Angular2原生Form支持： Angular2原生的Form模块功能相当强大。除了双向绑定之类的基本功能，还能通过programatic API 控
        制dom元素的表单行为。也有成型API提供自定义validator。这一点Vue只有v-model和第三方库。对于后台之类的重表单应用，还是
        Ng2有优势。
        3. 依赖注入无论你喜不喜欢DI，这就是Angular2的强大功能之一。有DI可以在不改变代码结构的情况下完成功能替换。（如，在
        desktop和mobile有不同功能，可以通过注入不同service实现，而共用相同的template和directive）。Vue则需要程序员自己规划代
        码组织，用来支持共享组件。比如，一个视频播放控件有几个子组件完成，子组件需要分享一个状态。这一点Angular2有原生的
        service injection pattern。而Vue则没有官方推荐。
        4. 对标准向后兼容Angular2在一些细节上对标准有更好的支持。比如list differ算法中Angular2 可以支持实现了Symbol.iterator
        的对象，而Vue只能支持Array。对Observable和Promise，Angular2在应用的各个地方，甚至模板级别都有支持(async pipe)。而Vue
        需要vue-rx等第三方库支持。Angular2的组件有shadow dom的实现可以选择，而Vue目前还没有。
        5. 测试Angular2一开始就设计好了如何对组件进行测试，而Vue组件虽然也很好写测试，但是没有官方推荐的唯一标准（当然，对视
        图是否需要测试还有待探讨）。除此以外，Angular2还有一些小功能比如检验模板的类型安全（即，模板里能在编译器保证没有引用
        model未定义的变量），不过AoT本身似乎还没有稳定，所以不能算优势。对TS的支持也是Angular好，当然前提是你喜欢TS。总体而
        言，就是Angular2里你能想到的都有了，你没想到的它也有了。框架的全面性是难以撼动的
        6.虽让angular有很多优点但是他也非常重，而且第三库如rxjs都不是自己维护相比vue个人全部是个人维护，修复问题也更快，而
        且vue上手简单，文档全，现在个人做到项目来说angular能做的vue同样也能做
        7.TypeScript自然有它的市场，但它有一些明显的问题，首先是JavaScript开发者需要再进一步学习，内容不少，也有一定陡峭的学
        习曲线，不过这还算小事情。重大的事情是需要把已经在使用的应用代码，都要整个改用TypeScript代码语法，才能发挥完整的功用
        这对很多已经有内部代码库的大型应用开发团队而言，将会是个重大的决定，因为如果不往全面重构的路走，将无法发挥强(静态)类
        型语言的最大效用，相对于非强制与非侵入性的acebook出品的flow.js来进行类型检查似乎更受本人喜爱。
            </pre> 
            <div class="explain">
                <a href="https://angular.cn/docs">angular中文网</a>&emsp;
                <a href="https://github.com/brillout/awesome-angular-components">angular插件</a>&emsp;
                <a href="https://github.com/limingkang/angular-webpack-starter">angular项目架构实践</a>&emsp;
                <a href="https://www.tslang.cn/docs/handbook/basic-types.html">typescript语法</a>&emsp;
                <a href="http://www.typescriptlang.org/docs/handbook/tsconfig-json.html">tsconfig文件配置</a>
            </div>                                                                                                    
            
            <div class="title">angular中form表单的使用，响应式模型驱动表单</div>
            <textarea style="border: 1px solid #D7D8C8;height: 1610px;width: 100%;background-color: #FDFEFB;" readonly="readonly">
        //html结构设计
        <form [formGroup]="userForm">
            <label>姓名:</label>
            <input type="text" formControlName="name">
            <span *ngIf="userForm.controls.name.pristine">未修改</span>
            <span *ngIf="userForm.controls.name.dirty">已修改</span>
            <span *ngIf="userForm.controls.name.valid">有效</span>
            <div [hidden]="userForm.controls.name.valid||userForm.controls.name.pristine">
                <p *ngIf="userForm.controls.name.errors?.minlength">姓名最小长度为3</p>
                <p *ngIf="userForm.controls.name.errors?.required">必须输入姓名</p>
                <p>{{userForm.controls.name.className}}</p>        //验证器的有效否会调用相应class如ng-valid,ng-invalid等
            </div>
            <label>电话:</label>
            <input type="text" formControlName="mobile">

            <fieldset formGroupName="address">
                <label>城市:</label>
                <input type="text" formControlName="city">
                <label>街道:</label>
                <input type="text" formControlName="street">
            </fieldset>
            <button type="submit">保存</button>
        </form>
        //组件内容,其中的验证器也可以自定义，当然在模板驱动和模型驱动下方法不同,上网可查此处不再赘述
        import{ Component, OnInit }from'@angular/core';
        import{ FormGroup, FormControl, FormBuilder, Validators }from'@angular/forms';

        export class ReactiveFormsComponent implements OnInit{
            userForm: FormGroup;
            constructor(private formBuilder: FormBuilder) {}
            ngOnInit() {
                this.userForm =this.formBuilder.group({
                    name: ['张三', [Validators.required, Validators.minLength(3)]],
                    mobile: [13800138001, [Validators.required, Validators.minLength(11), Validators.maxLength(11)]],
                    address: this.formBuilder.group({
                        city: ['北京', Validators.required],
                        street: ['朝阳望京...', Validators.required]
                    })
                });

                // 也可以创建响应式表单，从表单控件中获得地址、城市、街道控件的引用
                // 地址控件也是一个FormGroup，需要将它转型成FormGroup类型
                // 要引入 import'rxjs/add/operator/debounceTime';
                // 要引入 import'rxjs/add/operator/distinctUntilChanged';
                const addr$ = <FormGroup>this.userForm.controls['address'];
                const city$ = addr$.controls['city'];
                const street$ = addr$.controls['street'];
                city$.valueChanges.debounceTime(1000).distinctUntilChanged().subscribe(cityValue => {
                    this.msg = cityValue + ' 欢迎你!';
                    street$.setValue(cityValue);
                });
                this.userForm.valueChanges.subscribe(x => this.changeMsg = { event: 'Form DATA CHANGED', object: x });
                }
                reset() {
                    // 我们同样可以使用reset方法来重置数据
                    this.userForm.reset();
                }
            }
        }


        模板驱动表单一个简单例子:
        <form class="form_layout" (ngSubmit)="login()" #loginForm="ngForm" [hidden]="registermark">
            <div>
                <input type="text" name="loginname" pattern="^(?!\d+$)(?![a-zA-Z]+$)(?![!@#\$%\^\&\*]+$)[\w!@#\$%\^\&\*]{6,16}$" minlength="6" maxlength="16" required
                       autocomplete="off" [(ngModel)]="model.loginname" #loginname="ngModel">
                <small [class.myhidden]="loginname.valid || loginname.pristine">输入正确用户名</small>
                <div [hidden]="!loginname.errors?.pattern && !loginname.errors?.required">更加精确的哪一个格式不合法</div>
            </div>
            <button [disabled]="loginForm.form.invalid" type="submit">登录</button>
        </form>
            </textarea>
            <div class="explain">根传统的模板驱动的form表单相比，使用模型驱动的表单，我们的页面可以很整洁，没有验证器，没有
            数据绑定，没有 onChange , onBlur 等事件绑定，这些都在组件中完成，这对于测试会非常容易。所以，当你有一个表单，考
            虑用哪种表单创建方式的时候，如果这个表单比较简单，甚至不需要测试，那就用模板驱动的表单就可以。如果表单比较复杂
            就应该考虑使用模型驱动的表单方式</div>

            <div class="title">HTML attribute 与 DOM property 的对比</div>
            <pre>
        1.attribute 初始化 DOM property，然后它们的任务就完成了。property 的值可以改变；attribute 的值不能改变。
        如浏览器渲染<span><</span>input type="text" value="Bob">时,将创建相应DOM节点,其value property 被初始化为 “Bob”。
        当用户在输入框中输入 “Sally” 时，DOM 元素的value property 变成了 “Sally”。 但是这个 HTML value attribute 保持不变
        如果我们读取 input 元素的 attribute，就会发现确实没变： input.getAttribute('value') // 返回 "Bob"

        2.模板绑定是通过 property 和事件来工作的，而不是 attribute，所以在 Angular 的世界中，attribute 唯一的作用是用来初
        始化元素和指令的状态。 当进行数据绑定时，只是在与元素和指令的 property 和事件打交道，而 attribute 就完全靠边站了

        3.当元素没有属性可绑的时候，就必须使用 attribute 绑定例如colspan只能使用[attr.colspan]='expression';
        [class]="badCurly"当badCurly有值时候则class全部覆盖为这个值,而[class.classname]='expression'如果expression为真那么
        增加这个类名否则移除这个类名;style标签则使用[style.font-size.em]="isSpecial ? 3 : 1";或者我们使用ngClass、ngStyle来
        返回键值对对象

        4.angular的数据绑定有三种
            从数据源到视图使用的是
                {{expression}}
                [target]="expression"
                bind-target="expression"
            从视图到数据源使用，一般是事件如click等或者是组件的输出值
                (target)="statement"
                on-target="statement"
            双向绑定使用  
                [(target)]="expression"
                bindon-target="expression"    

        5.双绑的原理
        //select框记得用(change)解决
        <span><</span>input [value]="currentHero.name" (input)="currentHero.name=$event.target.value" >
        //ngModel输入属性会设置该元素的值，并通过ngModelChange的输出属性来监听元素值的变化
        <span><</span>input [ngModel]="currentHero.name" (ngModelChange)="currentHero.name=$event">
            </pre>

            <div class="title">angular动画</div>
            <pre>
        1.首先安装动画npm install @angular/animations --save，之后加载他import @angular/animations,还有在一个模块：
            import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
        2.注意还要imports进去,然后就可以开始写动画animate.ts
            import {trigger, state, style, animate, transition,keyframes} from '@angular/animations';
            export const SingalAnimate = trigger('signal', [
                state('go', style({
                    'background-color': 'green',
                    'height':'100px'
                })),
                state('stop', style({
                    'background-color':'red',
                    'height':'50px'
                })),
                transition('void => *', animate(5000, keyframes([  //void状态表示元素没有被附加到视图
                    style({'transform': 'scale(0)', offset: 0}),   //offset偏移量没写则均分
                    style({'transform': 'scale(0.1)', offset: 0.5}),
                    style({'transform': 'scale(1)', offset: 1})
                ]))),
                transition('* => void', [       //离场动画组
                    group([
                        animate('0.3s ease', style({
                          transform: 'translateX(50px)',
                          width: 10
                        })),
                        animate('0.3s 0.2s ease', style({
                          opacity: 0
                        }))
                    ])
                ]),
                transition('* => *', animate('.5s 1s cubic-bezier(0.2, 0.8, 0.3, 1.8)'))
            ]);
        3.组件ts里：import { SingalAnimate } from './animate';在元数据animation里添加：animations: [ SingalAnimate ]
        4.在组件html里面使用：
            <textarea readonly>
                <div (@signal.start)="animationStarted($event)"
                 (@signal.done)="animationDone($event)"   [@signal]="'go'"></div>
            </textarea>
        回调接收一个参数包含一些属性，例如fromState，toState和totalTime。无论动画是否实际执行过，那些回调都会触发。
            </pre>

            <div class="title">angular路由简单用法</div>
            <pre style="overflow-x: hidden;">
        页面中a标签写入方式,注意我们的router-outlet还可以写name属性，之后在路由中写对应outlet属性即可：
        routerLink="/portal/login" routerLinkActive="active"  
        //当前面没有/时候protal/login就是意味着在当前路由路径后面加上这个地址来匹配的
        //路由地址为/portal/register/12/detail
        [routerLink]="['/portal/register',id,'detail']" routerLinkActive="active"
        //路由地址为/home/todoList?id=12&type=important
        [routerLink]="['/home/todoList']" [queryParams]="{id: id, type: 'important'}" routerLinkActive="active"  
        手动触发时候想要引入router:Router对象之后
        this.router.navigate(['/portal/register', this.newid ,'detail']);
        this.router.navigate(['/portal/login'], { queryParams: { id: this.id, type:'important'} });  

        取值的时候先引入router:ActivatedRoute：
        组件级别的变化用它，只有当/todo/list到/todo/all是切换到不同组件的时候才会触发
        var lettodo=+this.route.snapshot.params['id'];
        当只是换值拉去数据的时候用它即/todo/1到/todo/2是同一组件不同值时候
        this.route.params.subscribe(params => {
            console.log(params);   // {id: "xxx",details:"xxx"}对应路径匹配为todo/:id/:detail
        });
        如果想获取问号拼的那样的值只是需要将上面的params换成queryParams即可  

        路由钩子：  
        CanActivate：这种类型的Guard用来控制是否允许进入当前的路径。注意这里即使没有被激活懒加载模块仍旧会加载
        CanActivateChild：这种类型的Guard用来控制是否允许进入当前路径的所有子路径。
        CanDeactivate：用来控制是否能离开当前页面进入别的路径
        CanLoad：用于控制一个异步加载的子模块是否允许被加载，它是先与CanActivate运行的


        详细路由参数记录：
        [routerLink]="['data',{ key : 'value' }]" [queryParams]="{ name : 'keatkeat' }" fragment="someWhere"
        this.router.navigate(
            ["data", { key: "value" }], 
            //data 是 child path, {key : "value"} 是 Matrix Url (矩阵 URL) 长这样 /data;key=value
            {
                relativeTo: this.route, 
                //默认值为根路由，设置后相对当前路由跳转，route是ActivatedRoute的实例，使用需要导入ActivatedRoute 
                queryParams: {
                    'name': "keatkeat" // ng 会对值调用 toString + encode 才放入 url 中, 解析时会 decode
                },
                //一般的 queryParams, 这里只能 override 整个对象, 如果你只是想添加一个的话，你必须自己实现保留之前的全部.         
                fragment: "someWhere",     //#可理解为锚点坐标
                replaceUrl : true          //有时候我们希望 replace history 而不是 push history 
                preserveQueryParams: true  //默认false,设为true,保留之前路由中查询参数/user?id=1 to /view?id=1
                preserveFragment: true     //默认false,设为true,保留之前路由中锚点/user/1#top to /view#top
                skipLocationChange: true //默认值为false,设为true路由跳转时浏览器中url保持不变,但传入的参数依然有效

            }
        );


        hash值定位跳转问题，这是angular2固有问题，提供一个简单解决方案：
        import {Router, NavigationEnd} from '@angular/router';
        this.router.events.subscribe(s => {
            if (s instanceof NavigationEnd) {
                const tree = this.router.parseUrl(this.router.url);
                if (tree.fragment) {
                   const element = document.querySelector("#" + tree.fragment);
                   if (element)  element.scrollIntoView(element);
                }
            }
        })
        这时候跳转写入fragment参数即可，记住页面上要有相应id
            </pre>
            <div class="explain">
                angular的路由只能有两层模块好像，就是说当你更模块可以写路由，之后再引入模块中，引入的模块还能写路由，
                当是如果想在引入的模块中在来一层模块写路由，他会将其当做第一层路由匹配
            </div>

            <div class="title">angular的请求</div>
            <pre style="overflow-x: hidden;">
        import {Headers, Http, URLSearchParams, Response,RequestOptions} from '@angular/http';
        import { Observable } from 'rxjs/Observable';
        import 'rxjs/add/operator/catch';
        import 'rxjs/add/operator/map';
        getHeroes(): Observable<span><</span>any> {
            var params: URLSearchParams = new URLSearchParams();
            params.set("test","value");
            return this.http.get(url,{search:params})
                    .map(this.extractData)
                    .catch(this.handleError);
            注意当传的是{search:params}时候我们是在url后面拼接，但是如果要是urlencode形式的话就直接写params就行了
                    urlencode时候这样写：return this.http.get(url,params,options)
            这是因为当get请求时候，浏览器用x-www-form-urlencoded的编码方式把数据转换成一个字串name1=value1&name2=value2
            然后把这个字串append到url后面,用?分割。 当为post时，数据会做一些处理变成formdata形式到http body中
        }
        private extractData(res: Response) {
            let body = res.json();
            return body.data || { };
        }
        private handleError (error: Response | any) {
            let errMsg: string;
            if (error instanceof Response) {
              const body = error.json() || '';
              const err = body.error || JSON.stringify(body);
              errMsg = `${error.status} - ${error.statusText || ''} ${err}`;
            } else {
              errMsg = error.message ? error.message : error.toString();
            }
            console.error(errMsg);
            return Observable.throw(errMsg);
        }  
        其他地方只要引入这个服务调用订阅就行了
        this.heroService.getHeroes()
            .subscribe(
               heroes => this.heroes = heroes,
               error =>  this.errorMessage = <span><</span>any>error); 

        上面是rxjs的流式操作的方法最后去订阅，也可以强制改为promise对象
        return this.http.get(url,{ search: params})
           .toPromise()
           //.then(response => response.text())如果直接返回一个字符串就不能用json方法解析用text
           .then(response => response.json())
           .catch(this.handleError); 
        如此的话调用的时候就是：
        this.heroService.getHeroes()
            .then(
               heroes => this.heroes = heroes,
               error =>  this.errorMessage = <span><</span>any>error);  

        对于post请求大体基本是一样的
        getHeroes(): Observable<span><</span>any> {
            let headers = new Headers({ 'Content-Type': 'application/json' });
            let options = new RequestOptions({ headers: headers,search: params });
            let senddata={test:3333};
            //json时候你传的值在请求体request payload中可以看
            return this.http.post(url,senddata,options)
                    .map(this.extractData)
                    .catch(this.handleError);

            //x-www-form-urlencoded的时候在form data中可以看而且注意其格式'test=3&lmk=33'
            //let headers = new Headers({ 'Content-Type': 'application/x-www-form-urlencoded;charset=utf-8' });   
            //let options = new RequestOptions({ headers: headers,search: params });
            //var senddata: URLSearchParams = new URLSearchParams();
            //senddata.set("test","value"); 
            //return this.http.post(url,senddata,options)
            //        .map(this.extractData)
            //        .catch(this.handleError);       
        }



        多个异步流的时候有提供类似于promise.all的方法forkJoin
        import 'rxjs/add/observable/forkJoin';
        import 'rxjs/add/operator/map';
        loadBaseSet():Observable<span><</span>any> {
          let whole = this.http.get('wbb/setting/global/readConfigLog?contextName=console');
          let email = this.http.get('wbb/setting/mail/readMail');
          let redis = this.http.get('wbb/setting/sysconf/readRedis');
          return Observable.forkJoin([whole,email, redis]).map((response)=>response.map((val,index,arr)=>val.json()))
        }
        调用的时候
        this.apiservice.loadBaseSet()
          .subscribe(
              response => {
                this.whole_situation=response[0];
                this.email_data=response[1];
                this.cache_data=response[2];
              },
              error => {
                Util.showMessage('数据获取失败', 'info');
              }); 



        要发起一个支持进度事件的请求，首先要创建一个设置过reportProgress选项的HttpRequest实例：
            const req = new HttpRequest('POST', '/upload/file', file, {
              reportProgress: true,
            });
        该选项让我们可以跟踪进度事件。记住，每个进度事件都会触发变更检测，所以应该只有在你真的打算在每个事件中更新 UI 时才打开它。
        接下来，通过HttpClient上的request()方法发起这个请求。其结果应该是一个关于事件的可观察对象，就像拦截器中看到的那样：
            http.request(req).subscribe(event => {
              // Via this API, you get access to the raw event stream.
              // Look for upload progress events.
              if (event.type === HttpEventType.UploadProgress) {
                // This is an upload progress event. Compute and show the % done:
                const percentDone = Math.round(100 * event.loaded / event.total);
                console.log(`File is ${percentDone}% uploaded.`);
              } else if (event instanceof HttpResponse) {
                console.log('File is completely uploaded!');
              }
            });
            </pre>
            <div class="explain">还有跨域的jsonp方法，输入搜索subject流的优化等，可查上面的angular中文网</div>

            <div class="title">angular请求拦截器等功能的写法</div>
            <pre style="overflow-x: hidden;">
        我们还可以编写新的服务注入模块中来改变请求时候的默认配置参数等：
        import { Injectable } from '@angular/core';
        import { BaseRequestOptions, RequestOptions } from '@angular/http';
        @Injectable()
        export class DefaultRequestOptions extends BaseRequestOptions {
          constructor() {
            super();
            // Set the default 'Content-Type' header
            this.headers.set('Content-Type', 'application/json');
          }
        }
        export const requestOptionsProvider = { provide: RequestOptions, useClass: DefaultRequestOptions };
        之后在模块中引入providers: [ requestOptionsProvider ] 


        上面是扩展原有服务配置的用法，我们可以重新写一个拦截器如日志记录
        需要这个拦截器的模块写法：
            import {NgModule} from '@angular/core';
            import {HTTP_INTERCEPTORS} from '@angular/common/http';
            @NgModule({
              providers: [{
                provide: HTTP_INTERCEPTORS,
                useClass: TimingInterceptor,
                multi: true,
              }],
            })
            export class AppModule {}
            注意multi: true选项。这是必须的，因为它会告诉 Angular 这个 HTTP_INTERCEPTORS 表示的是一个数组，而不是单个的值
        拦截器TimingInterceptor服务的写法：
            import {Injectable} from '@angular/core';
            import {HttpEvent, HttpInterceptor, HttpHandler, HttpRequest, HttpResponse} from '@angular/common/http';
            import 'rxjs/add/operator/do';    
            @Injectable()      
            export class TimingInterceptor implements HttpInterceptor {
              constructor() {}
              intercept(req: HttpRequest<span><</span>any>, next: HttpHandler): Observable<span><</span>HttpEvent<span><</span>any>> {
                const started = Date.now();
                return next
                  .handle(req)
                  .do(event => {
                    if (event instanceof HttpResponse) {
                      const elapsed = Date.now() - started;
                      console.log(`Request for ${req.urlWithParams} took ${elapsed} ms.`);
                    }
                  });
              }
            }
        一：RxJS 的 do()操作符 —— 它为可观察对象添加一个副作用，而不会影响到流中的值。这里，它会检测HttpResponse的事件，并且记录这
        个请求花费的时间;
        二：intercept是一个方法，它把一个请求对象转换成一个返回这个响应的可观察对象（Observable）。从这个意义上说，每个拦截器都要完
        全自己处理这个请求。当然，大多数时候，拦截器会对请求做一些小的修改，然后才把它转给拦截器链中的其它部分，也就是所传进来
        的next参数。next是一个HttpHandler，是一个类似于intercept的接口，它会把一个请求对象转换成一个可观察的响应对象。在拦截器中，
        next总是代表位于拦截器链中的下一个拦截器（如果有的话），如果没有更多拦截器了，它就会是最终的后端。所以，大多数拦截器的最
        后一句都会以它们转换后请求对象为参数调用next.handle函数;
        三：intercept和HttpHandler.handle返回的可观察对象并不是Observable<span><</span>HttpResponse<span><</span>any>>，
        而是Observable<span><</span>HttpEvent<span><</span>any>>。 这是因为拦截器所工作的层级要低于 HttpClient 接口。单
        个请求会生成多个事件，比如表示上传和下载过程的事件。HttpResponse类实际上本身也是一个事件，只是它的type是
        HttpEventType.HttpResponseEvent;
        四：当我们在一个应用中提供了多个拦截器时，Angular 会按照你提供时的顺序应用它们;    


        在一种情况下类型安全体系无法在写拦截器时保护请求体body，在拦截器中修改请求体本应是无效的，但类型检查系统无法发现它。
        如果确实需要修改请求体，我们就得自己复制它，修改这个复本，然后使用clone()来复制这个请求，并使用这个新的请求体。
        由于请求都是不可变的，所以不能直接修改它们。要想修改，就使用clone()函数： 
            intercept(req: HttpRequest<span><</span>any>, next: HttpHandler): Observable<span><</span>HttpEvent<span><</span>any>> {
              // This is a duplicate. It is exactly the same as the original.
              const dupReq = req.clone({headers: req.headers.set('Authorization', 'test')});

              // Change the URL and replace 'http://' with 'https://'
              //const secureReq = req.clone({url: req.url.replace('http://', 'https://')});
              return next.handle(dupReq)
            }   
            </pre>
            <div class="explain">当然还有http缓存等高级实用功能请查看相关文档</div>

            <div class="title">angular常用的几个小功能</div>
            <pre>
        1.安全导航操作符 (?.) 是一种流畅而便利的方式,如：
            The current hero's name is {{currentHero?.name}}当currentHero为空时候就会报错的，所以使用这个符号就不会，当然
            也可以使用The current hero's name is {{currentHero && currentHero.name}}来解决问题但是累赘 

        2.所有服务都是单例的，如果想生成新示例得在模块或组件中重新注册
        providers: [
            { provide: LocationStrategy, useClass: HashLocationStrategy },//在common模块中使用改变路由方式
            [LoggerHelper, {provide: Logger, useClass: BetterLogger}], // 带有依赖的注册商
            UserService,
            { provide: Hero,          useValue:    someHero },
            { provide: TITLE,         useValue:   'Hero of the Month' }, //值-提供商
            { provide: HeroService,   useClass:    HeroService },    //类-提供商
            { provide: MinimalLogger, useExisting: LoggerService },  //别名-提供商
            { provide: RUNNERS_UP,    useFactory:  runnersUpFactory(2), deps: [Hero, HeroService] } //工厂-提供商
        ] 
        上面的工厂提供商的函数不是提供商工厂函数。真正的提供商工厂函数是runnersUpFactory返回的函数
        function runnersUpFactory(take: number) {
          return (winner: Hero, heroService: HeroService): string => {
            /* ... */
          };
        };依赖两个服务，写在deps数组里面
        上面对象中provide对应你使用该服务的时候的使用方法的名字，useClass对应用来实例化的那个类的方法

        3.使用@Optional()和@Host()装饰器来限定依赖查找方式
        依赖可以被注入到任何组件级别,当组件申请一个依赖时，Angular从该组件本身的注入器开始，沿着依赖注入器的树往上找，直到
        找到第一个符合要求的提供商。如果Angular不能在这个过程中找到合适的依赖，它就会抛出一个错误,看构造函数
        constructor(
            @Host() // limit to the host component's instance of the HeroCacheService
            private heroCache: HeroCacheService,
            @Host()     // limit search for logger; hides the application-wide logger
            @Optional() // ok if the logger doesn't exist
            private loggerService: LoggerService
        ) {}
        @Host()函数是heroCache属性的装饰器，确保从其父组件HeroBioComponent得到一个缓存服务。如果该父组件不存在这个服务，
        Angular就会抛出错误，即使组件树里的再上级有某个组件拥有这个服务，Angular也会抛出错误;
        另一个@Host()函数是属性loggerService的装饰器，我们知道在应用程序中，只有一个LoggerService实例，也就是在AppComponent
        级提供的服务。 该宿主HeroBioComponent没有自己的LoggerService提供商;
        如果没有同时使用@Optional()装饰器的话，Angular就会抛出错误。多亏了@Optional()，Angular把loggerService设置为null，
        并继续执行组件而不会抛出错误;

        4.当编写一个继承自另一个组件的组件时，要格外小心。如果基础组件有依赖注入，必须要在派生类中重新提供和重新注入它们，
        并将它们通过构造函数传给基类，所以一定要避免组件的继承：
        @Component({
          selector: 'sorted-heroes',
          template: ``,
          providers: [HeroService]
        })
        export class SortedHeroesComponent extends HeroesBaseComponent {
          constructor(heroService: HeroService) {
            super(heroService);
          }
          protected afterGetHeroes() {}
        }
        现在，请注意afterGetHeroes()方法。 我们第一反应是在SortedHeroesComponent组件里面建一个ngOnInit方法来做排序。但是
        Angular会先调用派生类的ngOnInit，后调用基类的ngOnInit， 所以可能在英雄到达之前就开始排序。这就产生了一个讨厌的错误。
        所以覆盖基类的afterGetHeroes()方法可以解决这个问题

        5.依赖注入常用的用来限定注入行为的装饰器
            @Optional 如果找不到服务，设置参数为null
            @Attribute 注入宿主元素属性值
            @ContentChild 注入内容子组件
            @ViewChild 注入视图子组件
            @Host 注入本组件或它宿主中的服务
            @SkipSelf 注入本组件祖先中提供的服务

        6.angular2 模型数据更新了，需要监听数据改变,实现接口Docheck，检测页面上所有元素数据更新,这个代价很大
            import { Component, DoCheck,SimpleChanges,OnChanges } from "@angular/core";
            export class LangListUserComponent implements DoCheck,OnChanges {
                ngDoCheck() {
                  //只要输入组件的任何一个的数据变化了都会触发这个方法
                }
                ngOnChanges(changes: SimpleChanges) {
                    //使用这个检测一个数据forcefresh的变化
                    //如果组件没有输入属性的话那它永不触发
                    //如果在组件内手动改变输入属性的值，ngOnChanges 钩子是不会触发的
                    //我们在组件内部也可以改变输入属性的值该组件也会做出响应但是不建议这么做
                    if(changes['forcefresh'] && changes['forcefresh'].currentValue) {
                      this.forceRefresh();
                    }
                }
            }

        7.有的时候我们需要阻止一些事件冒泡等
            在事件中引入$event即可(click)="do($event)"
            之后在方法里面do(event:Event){
                event.stopPropagation();
            }
            或者直接绑定的时候就这样写：(click)="$event.stopPropagation(); doSomething()"

        8.通常我们会在ngOninit里面去做值的获取赋值等，但是里面必须是异步的，他会等待里面异步结束之后执行检测，否则直接赋值就：
                Expression has changed after it was checked. Previous value......
        这个错误就是说检测已经执行完了，但是值又变了，可是此时angular不会进行变更检测的，除非页面有点击输入什么的，这个报错是
        不会影响运行的，页面会正常显示，生产环境下不会报错，我们可以调用：
                import { enableProdMode } from '@angular/core';
                enableProdMode();  这方法会调用生产模式就不会再报错了，但是不建议用
        我们可以在要改值的地方使用一个异步即可使用observable订阅使用async或者settimeout等能造成异步的东西即可达到效果
            </pre>

            <div class="title">依赖注入@Injectable()介绍</div>
            <pre>
        @Component,@Directive和@Pipe是 Injectable 的子类型。正是这些@Injectable()装饰器是把一个类标识为注入器实例化的目标 
        @Directive可用来自定义结构指令和属性指令如：
            import {Directive, Input, ElementRef, Renderer, HostListener} from "@angular/core";
            @Directive({
              selector: '[exeBackground]'
            })
            export class ExeBackgroundDirective {
              private _defaultColor = 'yellow';

              @Input('exeBackground')
              backgroundColor: string; // 输入属性，用于设置元素的背景颜色

              constructor(private elementRef: ElementRef, private renderer: Renderer) {
                this.setStyle(this._defaultColor);
              }

              @HostListener('click')
              onClick() { // 监听宿主元素的点击事件，设置元素背景色
                this.setStyle(this.backgroundColor || this._defaultColor);
              }

              private setStyle(color: string) { // 调用renderer对象提供的API设置元素的背景颜色
                this.renderer.setElementStyle(this.elementRef.nativeElement, 
                  'backgroundColor', color);
              }
            }

            import { Component } from '@angular/core';
            @Component({
              selector: 'my-app', 
              template: `<span><</span>h1 [exeBackground]="'red'">Hello {{name}}<span><</span>/h1>`,
            })
            export class AppComponent  {
              name = 'Angular'; 
            }       
            </pre>
            <div class="explain">实际上组件也是继承与指令的</div>

            <div class="title">获取父子组件的引用</div>
            <pre>
        在Angular里，获取一个组件的引用比较复杂。虽然Angular应用程序是一个组件树，但它没有公开的API来在该树中巡查和穿梭。
        有一个API可以获取子级的引用(请看API参考手册中的Query, QueryList, ViewChildren,和ContentChildren);但没有公开的API来
        获取父组件的引用。但是因为每个组件的实例都被加到了依赖注入器的容器中，可以使用Angular依赖注入来找到父组件。

        如果只想在父组件的模板中使用子组件的方法只要：<span><</span>child-component #timer><span><</span>/child-component> 
        父组件模板中像timer.stop()这样使用就行
        如果想在父组件ts中文件中引用就得import { AfterViewInit, ViewChild ,ElementRef} from '@angular/core';
        @ViewChild('timer') timerComponent: any;    // string类型
        @ViewChild(childcomponent) timerComponent: childcomponent;    // type类型
        ngAfterViewInit() {
            setTimeout(() => this.seconds = () => this.timerComponent.seconds, 0);
        }  

        如果子组件想获取父组件引用并且知道父组件类名的话可以constructor( @Optional() public alex: antParentComponent ) {}
        但是我们的组件一般是公用的，可能是多个组件的子组件所以我们可以这样写：
            父组件：providers: [{ provide: Parent, useExisting: forwardRef(() => SelfComponentName) }]
            Parent是该提供商的类-接口令牌。SelfComponentName引用了自身，造成循环引用，使用forwardRef打破了该循环 
            子组件中：constructor( @Optional() public parent: Parent ) { }
        如果是多级，第一级还是那样写,第二级除了在providers像上面那样写,构造函数得加个标识,最后一级还是像上面那样正常写  
            constructor( @SkipSelf() @Optional() public parent: Parent ) { }
            添加@SkipSelf主要是出于两个原因：
                它告诉注入器从一个在自己上一级的组件开始搜索一个Parent依赖
                如果没写@SkipSelf装饰器的话，Angular就会抛出一个循环依赖错误 
            </pre>
            <div class="explain">
                应用程序组件经常需要共享信息。我们喜欢更加松耦合的技术，比如数据绑定和服务共享。 但有时候组件确实需要拥有
                另一个组件的引用，用来访问该组件的属性值或者调用它的方法,同级组件之间我们可以通过引用在模板中使用来传递信息
            </div>

            <div class="title">angular2的变更检测机制</div>
            <pre>
        对于angular2来说如果使用默认的检测策略，每当发生变化时，都会从根组件开始，从上往下在每个组件上执行变化检测。但如果子组件中的
        输入属性没有发生变化，是没有必要再执行变化检测。针对这种情况，Angular 2 为我们提供了 OnPush 的检测策略

        import { Component, Input, OnInit, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core';
        @Component({
            selector: 'exe-child',
            template:"{{counter}}",
            changeDetection: ChangeDetectionStrategy.OnPush
        })
        export class ChildComponent implements OnInit {
            @Input() counter: number = 0;

            constructor(private cdRef: ChangeDetectorRef) {}
            
            ngOnInit() {
                setInterval(() => {
                    this.counter++;
                    this.cdRef.markForCheck();
                }, 1000);
            }
        } 
        markForCheck():
            在组件metadata设置changeDetection: ChangeDetectionStrategy.OnPush,变化检测不会再次执行,除非手动调用该方法
        以下的其他方法不依赖雨changeDetection: ChangeDetectionStrategy.OnPush设置
        detach() - 从变化检测树中分离变化检测器，该组件的变化检测器将不再执行变化检测，除非手动调用 reattach() 方法
        reattach() - 重新添加已分离的变化检测器，使得该组件及其子组件都能执行变化检测
        detectChanges() - 从该组件到各个子组件执行一次变化检测 


        使用 Observables 机制提升性能和不可变的对象类似，但当发生变化的时候，Observables 不会创建新的模型，但我们可以通过订阅 
        Observables 对象，在变化发生之后，进行视图更新。使用Observables机制的时候，我们同样需要设置子组件变化检测策略为OnPush
        例如在父组件中对要输入给子组件的值：
            counterStream: Observable<span><</span>any>;
            this.counterStream = Observable.timer(0, 1000); 
        在子组件中我们使用：
            @Input() counterStream: Observable<span><</span>any>;
            constructor(private cdRef: ChangeDetectorRef) { }
            ngOnInit() {
                this.counterStream.subscribe(() => {
                    this.counter++;
                    this.cdRef.markForCheck();
                });
            }  



        ChangeDetectionStrategy 变化检测策略总共有几种 ？
            export declare enum ChangeDetectionStrategy {
                OnPush = 0, // 变化检测器的状态值是 CheckOnce
                Default = 1, // 组件默认值 - 变化检测器的状态值是 CheckAlways，即始终执行变化检测
            }
        变化检测器的状态有哪几种 ？
            export declare enum ChangeDetectorStatus {
                CheckOnce = 0, // 表示在执行detectChanges之后，变化检测器的状态将会变成Checked
                Checked = 1, // 表示变化检测将被跳过，直到变化检测器的状态恢复成CheckOnce
                CheckAlways = 2, // 表示在执行detectChanges之后，变化检测器的状态始终为CheckAlways
                Detached = 3, // 表示该变化检测器树已从根变化检测器树中移除，变化检测将会被跳过
                Errored = 4, // 表示在执行变化检测时出现异常
                Destroyed = 5, // 表示变化检测器已被销毁
            } 
            </pre>

            <div class="title">搜索中formController的用法</div>
            <pre>
        1.先要在input中使用[formControl]='temp'  记住要引入FormsModule,ReactiveFormsModule两个模块
        2.temp=new FormControl();           
        3.selectCompany:Observable<span><</span>Array<span><</span>string>>;  //保存后台值   
        4.this.temp.valueChanges
            .debounceTime(400)         //延迟400毫秒
            .distinctUntilChanged()    //值未改变
            .switchMap((term:any) => this.riskService.search(term))  
            //switchMap会在处理每一个新的消息的时候，就直接把上一个消息注册的订阅方法直接取消掉
            .subscribe((result) => {    //订阅返回值
                this.selectCompany=JSON.parse(result)
            })
        5.点击之后也可给他强制赋值：
            this.temp.setValue(value,{emitEvent:false});  //后面参数是为了不让他出发上面的change事件
        6.对于上面的后台调用方法我们使用map才行：
            return this.http.get(url)
              .map((response) => response.json());     
            </pre>

            <div class="title">动态创建组件的一种简单方案</div>
            <pre>
        针对我的项目场景：用户拖动相关的块到特定区域，区域中便会生成相应的UI控件，此UI控件有自己的模板、行为等等。生成UI 后便会在区域
        中显示出来。所以我觉得将UI控件封为一个小组件，再动态加载，是个不错的方案。

        要实现这个功能，得先简单了解angular2 中相关的api,从@angular/core中导入:
            ViewChild：一个属性装饰器，用来从模板视图中获取对应的元素，可以通过模板变量获取，获取时可以通过 read 属性设置查询的条件，
            就是说可以把此视图转为不同的实例
            ViewContainerRef ：一个视图容器，可以在此上面创建、插入、删除组件等等
            ComponentFactoryResolve：一个服务，动态加载组件的核心，这个服务可以将一个组件实例呈现到另一个组件视图上
        有了这三个，一个简单的思路便连贯了：特定区域就是一个视图容器，可以通过 ViewChild 来实现获取和查询，然后使用
        ComponentFactoryResolve将已声明未实例化的组件解析成为可以动态加载的 component，再将此component 呈现到此前的视图容器中

        1.在父组件中我们使用
            constructor(private cfr : ComponentFactoryResolver) { }
            @ViewChild("target", { read : ViewContainerRef }) target : ViewContainerRef
            addcomponent(){
                let factory = this.cfr.resolveComponentFactory(oneComponent);  
                let component = this.target.createComponent(factory, 0);
            }
        2.在模块中声明该组件还得增加entryComponents:[onecomponent]

        3.如果你使用的是预编译的话就会有问题了，可以手动加入@angular/compiler包并做相应配置但是这就没意义了
        
            </pre>
            <div class="explain">
                angular2的变异过程大体可以分为三步就是Inputs(源代码)-----Parser(解析器)----->Instantiate(实例化),如果不是aot的话就是
                这三个过程全部浏览器去做，但是如果是aot的话就是服务器端通过compiler-cli来把它变成parser后的代码但是实例化(真正创建dom)
                还是在浏览器端实现
            </div>

            <div class="title">angular中asyncPipe中的用法</div>
            <pre>
        正常没用管道的情况下这样写：
            <textarea style="height: 650px;" readonly>
        <button (click)="newSeq()">New random sequence</button>
        <ul>
          <li [style.background-color]="item.color"
              *ngFor="let item of items">{{item.num}}</li>
        </ul>`

        export class AppComponent {
          ...
          subscription: Subscription;

          newSeq() {
            //每一次新的流出现都会创建一个订阅所以必须取消否则会有多个订阅事件发生
            if (this.subscription) {
              this.subscription.unsubscribe();
            }

            // generate a random color
            let color = '#' + Math.random().toString(16).slice(-6);

            this.subscription = Observable.interval(1000)
                  .scan((acc, num)=>[{num, color }, ...acc].slice(0, 5), [])
                  .subscribe(items => this.items = items);
          }
        }
        每次我们订阅一个Observable ，我们将它保存到组件实例的一个属性中。然后，当我们再次运
        行newSeq的时候，我们检查this.subscription是否存在，如果存在的话，我们就需要去调用
        unsubscribe来取消订阅。这就是为什么我们看不到我们的列表在各种颜色之间跳转，不管我
        们点击了按钮多少次,当然这里也可以使用switchMap来搞定
            </textarea> 

        当我们使用管道的时候就简单了:
            <textarea style="height: 550px;" readonly>
        <button (click)="newSeq()">New random sequence</button>
        <ul>
          <li [style.background-color]="item.color"
              *ngFor="let item of items | async">{{item.num}}</li>
        </ul>`
        export class AppComponent {
          items: Observable<any>;

          constructor () {
            this.newSeq();
          }

          newSeq() {

            // generate a random color
            let color = '#' + Math.random().toString(16).slice(-6);

            this.items = Observable.interval(1000)
                                   .scan((acc, num)=>[{num, color }, ...acc].slice(0, 5), []);
          }
        }
        AsyncPipe一旦组件被销毁，就会从Observables取消订阅。而且一旦表达式的引用发生变化，也会
        取消订阅，只要我们为此分配一个新的Observable，则AsyncPipe将自动取消订阅先前绑定的
        Observable！这不仅使我们的代码变得美观干净，还能保护我们免受非常微妙的内存泄漏
            </textarea>       
            </pre>
            <div class="explain">
                在变更检测方面，这意味着每次Observables 都可以检查所有组件。这是浪费资源。通过将组件的更改检测设置为OnPush，我们可以
                做得更好，这意味着如果输入（我们的案例中的数组）发生变化，它将只检查它的绑定
            </div>

            <div class="title">组件的生命周期</div>
            <pre>
        ngOnChanges:当被绑定的输入属性的值发生变化时调用，首次调用一定会发生在 ngOnInit之前

        ngOnInit:在第一轮 ngOnChanges 完成之后调用之后的不会再调用了.(也就是说当每个输入属性的值都被触发了一次ngOnChanges之后才
        会调用 ngOnInit ，此时所有输入属性都已经有了正确的初始绑定值)

        ngDoCheck：在每个 Angular 变更检测周期中调用

        ngAfterContentInit：当把内容投影进组件之后调用

        ngAfterContentChecked：内容投影进组件之后，每次完成被投影组件内容的变更检测之后调用

        ngAfterViewInit：初始化完组件视图及其子视图之后调用

        ngAfterViewChecked：初始化完组件视图及其子视图之后，每次做完组件视图和子视图的变更检测之后调用

        ngOnDestroy：当 Angular 每次销毁指令 / 组件之前调用

        ngOnInit() {
            console.log(2);
            var clear=setTimeout(()=>{
                this.type="risk";
                console.log(3);
                clearTimeout(clear);
            },0)
        }
        ngAfterContentInit(){
            console.log(1);
        }
        ngAfterContentChecked(){
            console.log(4);
        }
        ngAfterViewInit(){
            console.log(5);
        }
        ngAfterViewChecked(){
            console.log(6);
        }
        ngDoCheck(){
            console.log(7);
        }
        当组件被加载的时候输出：
        2  7  1  4  5  6  7  4  6  3  7  4  6  7  4  6  7  4  6  7  4  6......
        如果没有输入值的话就不会触发ngOnchanges,如果有的话则其第一个触发，初始化完成之后就会立即执行一次总的变更检测
        之后再正常填充内容即可，记住在接下来页面有输入值或者谁的点击触发等都会触发7 4 6这个组件的整个数据检测
        数据变化的检测一般发生异步事件中，例如： 
            - 浏览器事件，例如 click, mouseover, keyup 
            - setTimout 和 setInterval 
            - Ajax 请求
        于是 Angular 使用了 zone.js 这个大杀器来跟踪异步任务，并进行脏检查。zone.js 这个工具给所有 JavaScript 异步事件都提
        供了一个上下文。zone.js 可以实现异步任务的跟踪、分析、错误记录。zone.js 是利用重写浏览器异步函数的方法来实现的。
        类似于下面这样：
            var realTetTimeout = window.setTimeout;
            var beforeTask = ()=> { console.log('before task') };
            var afterTask = ()=> { console.log('after task') };
            window.setTimeout = (fn, time)=> {
              realTetTimeout(()=> {
                beforeTask();
                fn();
                afterTask();
              }, time);
            };            
            </pre>

            <div class="title">angular中的测试</div>
            <pre>
        以下只是简单的内联模板和外部模板的测试方法，关于测试有依赖组件等高级方法可在官网中查询不在赘述
        import {ComponentFixture,TestBed,ComponentFixtureAutoDetect} from '@angular/core/testing';
        import { By }              from '@angular/platform-browser';
        import { DebugElement }    from '@angular/core';

        import { BannerComponent } from './banner-inline.component';

        describe('BannerComponent (inline template)', () => {

          let comp:    BannerComponent;
          let fixture: ComponentFixture<span><</span>BannerComponent>;
          let de:      DebugElement;
          let el:      HTMLElement;

          //再每个测试程序之前，Jasmin都一次运行beforeEach函数：
          //在beforeEach中调用configureTestingModule，以便TestBed可以在运行每个测试之前都把自己重置回它的基础状态
          beforeEach(() => {
            //TestBed（测试台）是Angular测试工具集中的首要概念。 它创建Angular测试模块（一个@NgModule类），我们可以通过调用它
            //的configureTestingModule方法来为要测试的类生成模块环境。 其效果是，你可以把被测试的组件从原有的应用模块中剥离出
            //来，把它附加到一个动态生成的Angular测试模块上，而该测试模块可以为这些测试进行特殊裁剪。

            //configureTestingModule方法接受一个类似@NgModule的元数据对象。这个元数据对象具有标准Angular模块的大多数属性

            //这里的元数据对象只是声明了要测试的组件BannerComponent。 这个元数据中没有imports属性，这是因为：(a) 默认的
            //测试模块配置中已经有了BannerComponent所需的一切，(b) BannerComponent不需要与任何其它组件交互

            //这个默认的配置只是测试的基础性工作。稍后我们会调用TestBed.configureTestingModule来传入更多元数据，这些元数据定义了
            //额外的imports、declarations、providers和试用于这些测试的概要（Schema）.可选的override方法可以微调配置的各个方面
            TestBed.configureTestingModule({
              declarations: [ BannerComponent ], // 这里只是简单声明一下要测试的模块
              //这个服务可以进行自动变更检测，我们可以直接不写手动调用变更检测fixture.detectChanges()
              providers: [
                  { provide: ComponentFixtureAutoDetect, useValue: true }
                ]
            });


            //在配置好TestBed之后，我们可以告诉它创建一个待测组件的实例该方法封闭了当前的TestBed实例，以免将来再配置它。 我们不能
            //再调用任何TestBed的方法修改配置：不能调用configureTestingModule或任何override方法。否则TestBed就会抛出错误

            //createComponent方法返回ComponentFixture(可官网搜索一下查看还有哪些属性)，用来控制和访问已创建的组件所在的测试环境。
            //这个fixture提供了对组件实例自身的访问，同时还提供了用来访问组件的DOM元素的DebugElement对象
            fixture = TestBed.createComponent(BannerComponent);

            comp = fixture.componentInstance; // BannerComponent test instance

            // query for the title h1 by CSS element selector
            de = fixture.debugElement.query(By.css('h1'));
            el = de.nativeElement;
          });
            //在Angular初始化数据绑定或者调用生命周期钩子之前，它给测试者机会来查看或者改变组件的状态
          it('no title in the DOM until manually call `detectChanges`', () => {
            expect(el.textContent).toEqual('');
          });

          //每个测试程序都通过调用fixture.detectChanges()来通知Angular执行变更检测
          //TestBed.createComponent不会触发变更检测。该工具不会自动将组件的title属性值推送到数据绑定的元素
          it('should display original title', () => {
            fixture.detectChanges();
            expect(el.textContent).toContain(comp.title);
          });
          
          //Angular测试环境不会知道测试程序改变了组件的title属性。 自动检测只对异步行为比如承诺的解析、计时器
          //和DOM事件作出反应。 但是直接修改组件属性值的这种同步更新是不会触发自动检测的。 测试程序必须手动调
          //用fixture.detectChange()，来触发新一轮的变更检测周期,所以不如每次直接手动调用
          it('should display a different test title', () => {
            comp.title = 'Test Title';
            fixture.detectChanges();
            expect(el.textContent).toContain('Test Title');
          });
        }); 



        //测试外联模板的组件的方法(就是组件中有templateUrl和styleUrls配置的时候)
        //当有外联模板的时候必须给Angular模板编译器一些时间来读取文件，只需把beforeEach中的逻辑被拆分成了两个beforeEach其他一样
        //async参数的内容看起来非常像同步版beforeEach的函数体。 它并不能很明显的看出来这是异步函数。 比如它不返回承诺（Promise）
        //并且也没有标准Jasmine异步测试时常用的done函数作为参数。 内部实现上，async会把beforeEach的函数体放进一个特殊的异步测试区
        （async test zone），它隐藏了异步执行的内部机制
        import { async } from '@angular/core/testing';
        beforeEach(async(() => {
          //TestBed.configureTestingModule方法返回TestBed类，以便你可以链式调用TestBed的其它静态方法，比如compileComponents
          //TestBed.compileComponents方法会异步编译这个测试模块中配置的所有组件。 在这个例子中，BannerComponent是唯一要编译
          //的组件。 当compileComponents完成时，外部组件和css文件会被“内联”
          //WebPack用户不用调用compileComponents，因为它会在构建过程中自动内联模板和css，然后执行测试
          //compileComponents方法封闭了当前的TestBed实例，不能再调用任何TestBed的方法修改配置：不能调用configureTestingModule
          //或任何override...方法。如果这么做，TestBed就会抛出错误
          TestBed.configureTestingModule({
            declarations: [ BannerComponent ], // declare the test component
          })
          .compileComponents();  // compile template and css
        }));
        //测试运行器（runner）会先等待第一个异步beforeEach函数执行完再调用第二个
        beforeEach(() => {
          fixture = TestBed.createComponent(BannerComponent);
          comp = fixture.componentInstance; 
          de = fixture.debugElement.query(By.css('h1'));
          el = de.nativeElement;
        });  
        //compileComponents方法返回一个承诺，来让我们可以在它完成之后立即执行额外的任务。 比如，我们也可以把第二个beforeEach中的
        //同步代码移到一个compileComponents().then(...)回调中，从而只需要写一个beforeEach 
            </pre>
            <div class="explain">
                独立单元测试用于测试那些完全不依赖Angular或不需要注入值的类实例，测试程序会new出一个测试类的实例，为构造函数参数提供
                所需的测试替身，然后测试该实例的API接口;我们应该为管道和服务书写独立单元测试;我们也同样可以对组件写独立单元测试，独立
                单元测试无法体现组件与Angular的交互,就是不能发现组件类如何与它的模板或其它组件交互，这时你需要Angular测试工具集，Angular
                测试工具集包括TestBed类和一些来自@angular/core/testing的助手函数。
            </div>

        </div>
    </body>
</html>

