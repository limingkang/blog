<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="chrome=1">
        <title>Blog by limingkang</title>
        <link rel="stylesheet" href="stylesheets/styles.css">
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="description" content="前端开发记录">
        <meta name="keywords" content="angular">
    </head>
    <body>
        <div class="big_container">
            <div class="title">对于angular的想法</div>
            <pre>
        1.由于angular1的问题非常多，所以本人并不看好其发展，但是新出来的angular可以说其设计上性能上都有了巨大的飞跃，还是值得
        一学的。不得不说Angular相对于Vue的优势在Vue2.0之后已经削弱很多了。比如SSR（Vue2已经原生支持）和全栈式框架（官方推荐
        Vuex+Vue-Router），native端也有阿里巴巴的weex
        2. Angular2原生Form支持： Angular2原生的Form模块功能相当强大。除了双向绑定之类的基本功能，还能通过programatic API 控
        制dom元素的表单行为。也有成型API提供自定义validator。这一点Vue只有v-model和第三方库。对于后台之类的重表单应用，还是
        Ng2有优势。
        3. 依赖注入无论你喜不喜欢DI，这就是Angular2的强大功能之一。有DI可以在不改变代码结构的情况下完成功能替换。（如，在
        desktop和mobile有不同功能，可以通过注入不同service实现，而共用相同的template和directive）。Vue则需要程序员自己规划代
        码组织，用来支持共享组件。比如，一个视频播放控件有几个子组件完成，子组件需要分享一个状态。这一点Angular2有原生的
        service injection pattern。而Vue则没有官方推荐。
        4. 对标准向后兼容Angular2在一些细节上对标准有更好的支持。比如list differ算法中Angular2 可以支持实现了Symbol.iterator
        的对象，而Vue只能支持Array。对Observable和Promise，Angular2在应用的各个地方，甚至模板级别都有支持(async pipe)。而Vue
        需要vue-rx等第三方库支持。Angular2的组件有shadow dom的实现可以选择，而Vue目前还没有。
        5. 测试Angular2一开始就设计好了如何对组件进行测试，而Vue组件虽然也很好写测试，但是没有官方推荐的唯一标准（当然，对视
        图是否需要测试还有待探讨）。除此以外，Angular2还有一些小功能比如检验模板的类型安全（即，模板里能在编译器保证没有引用
        model未定义的变量），不过AoT本身似乎还没有稳定，所以不能算优势。对TS的支持也是Angular好，当然前提是你喜欢TS。总体而
        言，就是Angular2里你能想到的都有了，你没想到的它也有了。框架的全面性是难以撼动的
        6.虽让angular有很多优点但是他也非常重，而且第三库如rxjs都不是自己维护相比vue个人全部是个人维护，修复问题也更快，而
        且vue上手简单，文档全，现在个人做到项目来说angular能做的vue同样也能做
            </pre> 
            <div class="explain">
                <a href="https://angular.cn/docs">angular中文网</a>&emsp;
                <a href="https://github.com/limingkang/angular-webpack-starter">angular项目架构实践</a>&emsp;
                <a href="https://www.tslang.cn/docs/handbook/basic-types.html">typescript语法</a>&emsp;
                <a href="https://github.com/ng-book2/code">ng-book随书源码</a>
            </div>                                                                                                    
            
            <div class="title">angular中form表单的使用，响应式模型驱动表单</div>
            <textarea style="border: 1px solid #D7D8C8;height: 1590px;width: 100%;background-color: #FDFEFB;" readonly="readonly">
        //html结构设计
        <form [formGroup]="userForm">
            <label>姓名:</label>
            <input type="text" formControlName="name">
            <span *ngIf="userForm.controls.name.pristine">未修改</span>
            <span *ngIf="userForm.controls.name.dirty">已修改</span>
            <span *ngIf="userForm.controls.name.valid">有效</span>
            <div [hidden]="userForm.controls.name.valid||userForm.controls.name.pristine">
                <p *ngIf="userForm.controls.name.errors?.minlength">姓名最小长度为3</p>
                <p *ngIf="userForm.controls.name.errors?.required">必须输入姓名</p>
                <p>{{userForm.controls.name.className}}</p>        //验证器的有效否会调用相应class如ng-valid,ng-invalid等
            </div>
            <label>电话:</label>
            <input type="text" formControlName="mobile">

            <fieldset formGroupName="address">
                <label>城市:</label>
                <input type="text" formControlName="city">
                <label>街道:</label>
                <input type="text" formControlName="street">
            </fieldset>
            <button type="submit">保存</button>
        </form>
        //组件内容,其中的验证器也可以自定义，当然在模板驱动和模型驱动下方法不同,上网可查此处不再赘述
        import{ Component, OnInit }from'@angular/core';
        import{ FormGroup, FormControl, FormBuilder, Validators }from'@angular/forms';

        export class ReactiveFormsComponent implements OnInit{
            userForm: FormGroup;
            constructor(private formBuilder: FormBuilder) {}
            ngOnInit() {
                this.userForm =this.formBuilder.group({
                    name: ['张三', [Validators.required, Validators.minLength(3)]],
                    mobile: [13800138001, [Validators.required, Validators.minLength(11), Validators.maxLength(11)]],
                    address: this.formBuilder.group({
                        city: ['北京', Validators.required],
                        street: ['朝阳望京...', Validators.required]
                    })
                });

                // 也可以创建响应式表单，从表单控件中获得地址、城市、街道控件的引用
                // 地址控件也是一个FormGroup，需要将它转型成FormGroup类型
                // 要引入 import'rxjs/add/operator/debounceTime';
                // 要引入 import'rxjs/add/operator/distinctUntilChanged';
                const addr$ = <FormGroup>this.userForm.controls['address'];
                const city$ = addr$.controls['city'];
                const street$ = addr$.controls['street'];
                city$.valueChanges.debounceTime(1000).distinctUntilChanged().subscribe(cityValue => {
                    this.msg = cityValue + ' 欢迎你!';
                    street$.setValue(cityValue);
                });
                this.userForm.valueChanges.subscribe(x => this.changeMsg = { event: 'Form DATA CHANGED', object: x });
                }
                reset() {
                    // 我们同样可以使用reset方法来重置数据
                    this.userForm.reset();
                }
            }
        }


        模型驱动表单一个简单例子:
        <form class="form_layout" (ngSubmit)="login()" #loginForm="ngForm" [hidden]="registermark">
            <div>
                <input type="text" name="loginname" pattern="^(?!\d+$)(?![a-zA-Z]+$)(?![!@#\$%\^\&\*]+$)[\w!@#\$%\^\&\*]{6,16}$" minlength="6" maxlength="16" required
                       autocomplete="off" [(ngModel)]="model.loginname" #loginname="ngModel">
                <small [class.myhidden]="loginname.valid || loginname.pristine">输入正确用户名</small>
            </div>
            <button [disabled]="loginForm.form.invalid" type="submit">登录</button>
        </form>
            </textarea>
            <div class="explain">根传统的模板驱动的form表单相比，使用模型驱动的表单，我们的页面可以很整洁，没有验证器，没有
            数据绑定，没有 onChange , onBlur 等事件绑定，这些都在组件中完成，这对于测试会非常容易。所以，当你有一个表单，考
            虑用哪种表单创建方式的时候，如果这个表单比较简单，甚至不需要测试，那就用模板驱动的表单就可以。如果表单比较复杂
            就应该考虑使用模型驱动的表单方式</div>

            <div class="title">HTML attribute 与 DOM property 的对比</div>
            <pre>
        1.attribute 初始化 DOM property，然后它们的任务就完成了。property 的值可以改变；attribute 的值不能改变。
        如浏览器渲染<span><</span>input type="text" value="Bob">时,将创建相应DOM节点,其value property 被初始化为 “Bob”。
        当用户在输入框中输入 “Sally” 时，DOM 元素的value property 变成了 “Sally”。 但是这个 HTML value attribute 保持不变
        如果我们读取 input 元素的 attribute，就会发现确实没变： input.getAttribute('value') // 返回 "Bob"

        2.模板绑定是通过 property 和事件来工作的，而不是 attribute，所以在 Angular 的世界中，attribute 唯一的作用是用来初
        始化元素和指令的状态。 当进行数据绑定时，只是在与元素和指令的 property 和事件打交道，而 attribute 就完全靠边站了

        3.当元素没有属性可绑的时候，就必须使用 attribute 绑定例如colspan只能使用[attr.colspan]='expression';
        [class]="badCurly"当badCurly有值时候则class全部覆盖为这个值,而[class.classname]='expression'如果expression为真那么
        增加这个类名否则移除这个类名;style标签则使用[style.font-size.em]="isSpecial ? 3 : 1";或者我们使用ngClass、ngStyle来
        返回键值对对象

        4.angular的数据绑定有三种
            从数据源到视图使用的是
                {{expression}}
                [target]="expression"
                bind-target="expression"
            从视图到数据源使用，一般是事件如click等或者是组件的输出值
                (target)="statement"
                on-target="statement"
            双向绑定使用  
                [(target)]="expression"
                bindon-target="expression"    
            </pre>

            <div class="title">angular动画</div>
            <pre>
        1.首先安装动画npm install @angular/animations --save，之后加载他import @angular/animations,还有在一个模块：
            import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
        2.注意还要imports进去,然后就可以开始写动画animate.ts
            import {trigger, state, style, animate, transition,keyframes} from '@angular/animations';
            export const SingalAnimate = trigger('signal', [
                state('go', style({
                    'background-color': 'green',
                    'height':'100px'
                })),
                state('stop', style({
                    'background-color':'red',
                    'height':'50px'
                })),
                transition('void => *', animate(5000, keyframes([  //void状态表示元素没有被附加到视图
                    style({'transform': 'scale(0)', offset: 0}),   //offset偏移量没写则均分
                    style({'transform': 'scale(0.1)', offset: 0.5}),
                    style({'transform': 'scale(1)', offset: 1})
                ]))),
                transition('* => void', [       //离场动画组
                    group([
                        animate('0.3s ease', style({
                          transform: 'translateX(50px)',
                          width: 10
                        })),
                        animate('0.3s 0.2s ease', style({
                          opacity: 0
                        }))
                    ])
                ]),
                transition('* => *', animate('.5s 1s cubic-bezier(0.2, 0.8, 0.3, 1.8)'))
            ]);
        3.组件ts里：import { SingalAnimate } from './animate';在元数据animation里添加：animations: [ SingalAnimate ]
        4.在组件html里面使用：
            <textarea readonly>
                <div (@signal.start)="animationStarted($event)"
                 (@signal.done)="animationDone($event)"   [@signal]="'go'"></div>
            </textarea>
        回调接收一个参数包含一些属性，例如fromState，toState和totalTime。无论动画是否实际执行过，那些回调都会触发。
            </pre>

            <div class="title">angular路由简单用法</div>
            <pre>
        页面中a标签写入方式,注意我们的router-outlet还可以写name属性，之后在路由中写对应outlet属性即可：
        routerLink="/portal/login" routerLinkActive="active"  
        //当前面没有/时候protal/login就是意味着在当前路由路径后面加上这个地址来匹配的
        //路由地址为/portal/register/12/detail
        [routerLink]="['/portal/register',id,'detail']" routerLinkActive="active"
        //路由地址为/home/todoList?id=12&type=important
        [routerLink]="['/home/todoList']" [queryParams]="{id: id, type: 'important'}" routerLinkActive="active"  
        手动触发时候想要引入router:Router对象之后
        this.router.navigate(['/portal/register', this.newid ,'detail']);
        this.router.navigate(['/portal/login'], { queryParams: { id: this.id, type:'important'} });  

        取值的时候先引入router:ActivatedRoute：
        组件级别的变化用它，只有当/todo/list到/todo/all是切换到不同组件的时候才会触发
        var lettodo=+this.route.snapshot.params['id'];
        当只是换值拉去数据的时候用它即/todo/1到/todo/2是同一组件不同值时候
        this.route.params.subscribe(params => {
            console.log(params);   // {id: "xxx",details:"xxx"}对应路径匹配为todo/:id/:detail
        });
        如果想获取问号拼的那样的值只是需要将上面的params换成queryParams即可  

        路由钩子：  
        CanActivate：这种类型的Guard用来控制是否允许进入当前的路径。注意这里即使没有被激活懒加载模块仍旧会加载
        CanActivateChild：这种类型的Guard用来控制是否允许进入当前路径的所有子路径。
        CanDeactivate：用来控制是否能离开当前页面进入别的路径
        CanLoad：用于控制一个异步加载的子模块是否允许被加载，它是先与CanActivate运行的


        详细路由参数记录：
        [routerLink]="['data',{ key : 'value' }]" [queryParams]="{ name : 'keatkeat' }" fragment="someWhere"
        this.router.navigate(
            ["data", { key: "value" }], 
            //data 是 child path, {key : "value"} 是 Matrix Url (矩阵 URL) 长这样 /data;key=value
            {
                relativeTo: this.route, 
                //默认值为根路由，设置后相对当前路由跳转，route是ActivatedRoute的实例，使用需要导入ActivatedRoute 
                queryParams: {
                    'name': "keatkeat" // ng 会对值调用 toString + encode 才放入 url 中, 解析时会 decode
                },
                //一般的 queryParams, 这里只能 override 整个对象, 如果你只是想添加一个的话，你必须自己实现保留之前的全部.         
                fragment: "someWhere",     //#可理解为锚点坐标
                replaceUrl : true          //有时候我们希望 replace history 而不是 push history 
                preserveQueryParams: true  //默认false,设为true,保留之前路由中查询参数/user?id=1 to /view?id=1
                preserveFragment: true     //默认false,设为true,保留之前路由中锚点/user/1#top to /view#top
                skipLocationChange: true //默认值为false,设为true路由跳转时浏览器中url保持不变,但传入的参数依然有效

            }
        );


        hash值定位跳转问题，这是angular2固有问题，提供一个简单解决方案：
        import {Router, NavigationEnd} from '@angular/router';
        this.router.events.subscribe(s => {
            if (s instanceof NavigationEnd) {
                const tree = this.router.parseUrl(this.router.url);
                if (tree.fragment) {
                   const element = document.querySelector("#" + tree.fragment);
                   if (element)  element.scrollIntoView(element);
                }
            }
        })
        这时候跳转写入fragment参数即可，记住页面上要有相应id
            </pre>
            <div class="explain">
                angular的路由只能有两层模块好像，就是说当你更模块可以写路由，之后再引入模块中，引入的模块还能写路由，
                当是如果想在引入的模块中在来一层模块写路由，他会将其当做第一层路由匹配
            </div>

            <div class="title">angular的请求</div>
            <pre>
        import {Headers, Http, URLSearchParams, Response,RequestOptions} from '@angular/http';
        import { Observable } from 'rxjs/Observable';
        import 'rxjs/add/operator/catch';
        import 'rxjs/add/operator/map';
        getHeroes(): Observable<span><</span>any> {
            var params: URLSearchParams = new URLSearchParams();
            params.set("test","value");
            注意当传的是{search:params}时候我们是在url后面拼接，但是如果要是urlencode形式的话就直接写params就行了
            实际上传的就是"value1=1&value2=2"如return this.http.post(url,params,options)
            return this.http.get(url,{search:params})
                    .map(this.extractData)
                    .catch(this.handleError);
        }
        private extractData(res: Response) {
            let body = res.json();
            return body.data || { };
        }
        private handleError (error: Response | any) {
            let errMsg: string;
            if (error instanceof Response) {
              const body = error.json() || '';
              const err = body.error || JSON.stringify(body);
              errMsg = `${error.status} - ${error.statusText || ''} ${err}`;
            } else {
              errMsg = error.message ? error.message : error.toString();
            }
            console.error(errMsg);
            return Observable.throw(errMsg);
        }  
        其他地方只要引入这个服务调用订阅就行了
        this.heroService.getHeroes()
            .subscribe(
               heroes => this.heroes = heroes,
               error =>  this.errorMessage = <span><</span>any>error); 

        上面是rxjs的流式操作的方法最后去订阅，也可以强制改为promise对象
        return this.http.get(url,{ search: params})
           .toPromise()
           .then(response => response.json())
           .catch(this.handleError); 
        如此的话调用的时候就是：
        this.heroService.getHeroes()
            .then(
               heroes => this.heroes = heroes,
               error =>  this.errorMessage = <span><</span>any>error);  

        对于post请求大体基本是一样的
        getHeroes(): Observable<span><</span>any> {
            let headers = new Headers({ 'Content-Type': 'application/json' });
            let options = new RequestOptions({ headers: headers,search: params });
            let senddata={};
            return this.http.post(url,senddata,options)
                    .map(this.extractData)
                    .catch(this.handleError);
        } 


        我们还可以编写新的服务注入模块中来改变请求时候的默认配置参数等：
        import { Injectable } from '@angular/core';
        import { BaseRequestOptions, RequestOptions } from '@angular/http';
        @Injectable()
        export class DefaultRequestOptions extends BaseRequestOptions {
          constructor() {
            super();
            // Set the default 'Content-Type' header
            this.headers.set('Content-Type', 'application/json');
          }
        }
        export const requestOptionsProvider = { provide: RequestOptions, useClass: DefaultRequestOptions };
        之后在模块中引入providers: [ requestOptionsProvider ] 
            </pre>
            <div class="explain">还有跨域的jsonp方法，输入搜索subject流的优化等，可查上面的angular中文网;对于更多的默认参数设置以及http拦截器等可查网上资料</div>

            <div class="title">angular常用的几个小功能</div>
            <pre>
        1.安全导航操作符 (?.) 是一种流畅而便利的方式,如：
            The current hero's name is {{currentHero?.name}}当currentHero为空时候就会报错的，所以使用这个符号就不会，当然
            也可以使用The current hero's name is {{currentHero && currentHero.name}}来解决问题但是累赘 

        2.所有服务都是单例的，如果想生成新示例得在模块或组件中重新注册
        providers: [
            { provide: LocationStrategy, useClass: HashLocationStrategy },//在common模块中使用改变路由方式
            [LoggerHelper, {provide: Logger, useClass: BetterLogger}], // 带有依赖的注册商
            UserService,
            { provide: Hero,          useValue:    someHero },
            { provide: TITLE,         useValue:   'Hero of the Month' }, //值-提供商
            { provide: HeroService,   useClass:    HeroService },    //类-提供商
            { provide: MinimalLogger, useExisting: LoggerService },  //别名-提供商
            { provide: RUNNERS_UP,    useFactory:  runnersUpFactory(2), deps: [Hero, HeroService] } //工厂-提供商
        ] 
        上面对象中provide对应你使用该服务的时候的使用方法的名字，useClass对应用来实例化的那个类的方法

        3.使用@Optional()和@Host()装饰器来限定依赖查找方式
        依赖可以被注入到任何组件级别,当组件申请一个依赖时，Angular从该组件本身的注入器开始，沿着依赖注入器的树往上找，直到
        找到第一个符合要求的提供商。如果Angular不能在这个过程中找到合适的依赖，它就会抛出一个错误,看构造函数
        constructor(
            @Host() // limit to the host component's instance of the HeroCacheService
            private heroCache: HeroCacheService,
            @Host()     // limit search for logger; hides the application-wide logger
            @Optional() // ok if the logger doesn't exist
            private loggerService: LoggerService
        ) {}
        @Host()函数是heroCache属性的装饰器，确保从其父组件HeroBioComponent得到一个缓存服务。如果该父组件不存在这个服务，
        Angular就会抛出错误，即使组件树里的再上级有某个组件拥有这个服务，Angular也会抛出错误;
        另一个@Host()函数是属性loggerService的装饰器，我们知道在应用程序中，只有一个LoggerService实例，也就是在AppComponent
        级提供的服务。 该宿主HeroBioComponent没有自己的LoggerService提供商;
        如果没有同时使用@Optional()装饰器的话，Angular就会抛出错误。多亏了@Optional()，Angular把loggerService设置为null，
        并继续执行组件而不会抛出错误;

        4.当编写一个继承自另一个组件的组件时，要格外小心。如果基础组件有依赖注入，必须要在派生类中重新提供和重新注入它们，
        并将它们通过构造函数传给基类，所以一定要避免组件的继承：
        @Component({
          selector: 'sorted-heroes',
          template: ``,
          providers: [HeroService]
        })
        export class SortedHeroesComponent extends HeroesBaseComponent {
          constructor(heroService: HeroService) {
            super(heroService);
          }
          protected afterGetHeroes() {}
        }
        现在，请注意afterGetHeroes()方法。 我们第一反应是在SortedHeroesComponent组件里面建一个ngOnInit方法来做排序。但是
        Angular会先调用派生类的ngOnInit，后调用基类的ngOnInit， 所以可能在英雄到达之前就开始排序。这就产生了一个讨厌的错误。
        所以覆盖基类的afterGetHeroes()方法可以解决这个问题

        5.依赖注入常用的用来限定注入行为的装饰器
            @Optional 如果找不到服务，设置参数为null
            @Attribute 注入宿主元素属性值
            @ContentChild 注入内容子组件
            @ViewChild 注入视图子组件
            @Host 注入本组件或它宿主中的服务
            @SkipSelf 注入本组件祖先中提供的服务

        6.angular2 模型数据更新了，需要监听数据改变,实现接口Docheck，检测页面上所有元素数据更新,这个代价很大
            import { Component, DoCheck } from "@angular/core";
            export class LangListUserComponent implements DoCheck,OnChanges {
                ngDoCheck() {
                  //只要输入组件的任何一个的数据变化了都会触发这个方法
                }
                ngOnChanges(changes: SimpleChanges) {
                    //使用这个检测一个数据forcefresh的变化
                    //如果在组件内手动改变输入属性的值，ngOnChanges 钩子是不会触发的
                    if(changes['forcefresh'] && changes['forcefresh'].currentValue) {
                      this.forceRefresh();
                    }
                }
            }

        7.有的时候我们需要阻止一些事件冒泡等
            在事件中引入$event即可(click)="do($event)"
            之后在方法里面do(event:Event){
                event.stopPropagation();
            }
            </pre>

            <div class="title">获取父子组件的引用</div>
            <pre>
        在Angular里，获取一个组件的引用比较复杂。虽然Angular应用程序是一个组件树，但它没有公开的API来在该树中巡查和穿梭。
        有一个API可以获取子级的引用(请看API参考手册中的Query, QueryList, ViewChildren,和ContentChildren);但没有公开的API来
        获取父组件的引用。但是因为每个组件的实例都被加到了依赖注入器的容器中，可以使用Angular依赖注入来找到父组件。

        如果只想在父组件的模板中使用子组件的方法只要：<span><</span>child-component #timer><span><</span>/child-component> 
        父组件模板中像timer.stop()这样使用就行
        如果想在父组件ts中文件中引用就得import { AfterViewInit, ViewChild ,ElementRef} from '@angular/core';
        @ViewChild('timer') timerComponent: any;    // string类型
        @ViewChild(childcomponent) timerComponent: childcomponent;    // type类型
        ngAfterViewInit() {
            setTimeout(() => this.seconds = () => this.timerComponent.seconds, 0);
        }  

        如果子组件想获取父组件引用并且知道父组件类名的话可以constructor( @Optional() public alex: antParentComponent ) {}
        但是我们的组件一般是公用的，可能是多个组件的子组件所以我们可以这样写：
            父组件：providers: [{ provide: Parent, useExisting: forwardRef(() => SelfComponentName) }]
            Parent是该提供商的类-接口令牌。SelfComponentName引用了自身，造成循环引用，使用forwardRef打破了该循环 
            子组件中：constructor( @Optional() public parent: Parent ) { }
        如果是多级，第一级还是那样写,第二级除了在providers像上面那样写,构造函数得加个标识,最后一级还是像上面那样正常写  
            constructor( @SkipSelf() @Optional() public parent: Parent ) { }
            添加@SkipSelf主要是出于两个原因：
                它告诉注入器从一个在自己上一级的组件开始搜索一个Parent依赖
                如果没写@SkipSelf装饰器的话，Angular就会抛出一个循环依赖错误 
            </pre>
            <div class="explain">
                应用程序组件经常需要共享信息。我们喜欢更加松耦合的技术，比如数据绑定和服务共享。 但有时候组件确实需要拥有
                另一个组件的引用，用来访问该组件的属性值或者调用它的方法
            </div>

            <div class="title">angular2的变更检测机制</div>
            <pre>
        对于angular2来说如果使用默认的检测策略，每当发生变化时，都会从根组件开始，从上往下在每个组件上执行变化检测。但如果子组件中的
        输入属性没有发生变化，是没有必要再执行变化检测。针对这种情况，Angular 2 为我们提供了 OnPush 的检测策略

        import { Component, Input, OnInit, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core';
        @Component({
            selector: 'exe-child',
            template:"{{counter}}",
            changeDetection: ChangeDetectionStrategy.OnPush
        })
        export class ChildComponent implements OnInit {
            @Input() counter: number = 0;

            constructor(private cdRef: ChangeDetectorRef) {}
            
            ngOnInit() {
                setInterval(() => {
                    this.counter++;
                    this.cdRef.markForCheck();
                }, 1000);
            }
        } 
        markForCheck():
            在组件metadata设置changeDetection: ChangeDetectionStrategy.OnPush,变化检测不会再次执行,除非手动调用该方法
        以下的其他方法不依赖雨changeDetection: ChangeDetectionStrategy.OnPush设置
        detach() - 从变化检测树中分离变化检测器，该组件的变化检测器将不再执行变化检测，除非手动调用 reattach() 方法
        reattach() - 重新添加已分离的变化检测器，使得该组件及其子组件都能执行变化检测
        detectChanges() - 从该组件到各个子组件执行一次变化检测 


        使用 Observables 机制提升性能和不可变的对象类似，但当发生变化的时候，Observables 不会创建新的模型，但我们可以通过订阅 
        Observables 对象，在变化发生之后，进行视图更新。使用Observables机制的时候，我们同样需要设置组件变化检测策略为OnPush
        例如在父组件中对要输入给子组件的值：
            counterStream: Observable<span><</span>any>;
            this.counterStream = Observable.timer(0, 1000); 
        在子组件中我们使用：
            @Input() counterStream: Observable<span><</span>any>;
            constructor(private cdRef: ChangeDetectorRef) { }
            ngOnInit() {
                this.addStream.subscribe(() => {
                    this.counter++;
                    this.cdRef.markForCheck();
                });
            }  



        ChangeDetectionStrategy 变化检测策略总共有几种 ？
            export declare enum ChangeDetectionStrategy {
                OnPush = 0, // 变化检测器的状态值是 CheckOnce
                Default = 1, // 组件默认值 - 变化检测器的状态值是 CheckAlways，即始终执行变化检测
            }
        变化检测器的状态有哪几种 ？
            export declare enum ChangeDetectorStatus {
                CheckOnce = 0, // 表示在执行detectChanges之后，变化检测器的状态将会变成Checked
                Checked = 1, // 表示变化检测将被跳过，直到变化检测器的状态恢复成CheckOnce
                CheckAlways = 2, // 表示在执行detectChanges之后，变化检测器的状态始终为CheckAlways
                Detached = 3, // 表示该变化检测器树已从根变化检测器树中移除，变化检测将会被跳过
                Errored = 4, // 表示在执行变化检测时出现异常
                Destroyed = 5, // 表示变化检测器已被销毁
            } 
            </pre>

            <div class="title">搜索中formController的用法</div>
            <pre>
        1.先要在input中使用[formControl]='temp'  记住要引入FormsModule,ReactiveFormsModule两个模块
        2.temp=new FormControl();           
        3.selectCompany:Observable<span><</span>Array<span><</span>string>>;  //保存后台值   
        4.this.temp.valueChanges
            .debounceTime(400)         //延迟400毫秒
            .distinctUntilChanged()    //值未改变
            .switchMap((term:any) => this.riskService.search(term))  
            //switchMap会在处理每一个新的消息的时候，就直接把上一个消息注册的订阅方法直接取消掉
            .subscribe((result) => {    //订阅返回值
                this.selectCompany=JSON.parse(result)
            })
        5.点击之后也可给他强制赋值：
            this.temp.setValue(value,{emitEvent:false});  //后面参数是为了不让他出发上面的change事件
        6.对于上面的后台调用方法我们使用map才行：
            return this.http.get(url)
              .map((response) => response.json());     
            </pre>

            <div class="title">动态创建组件的一种简单方案</div>
            <pre>
        针对我的项目场景：用户拖动相关的块到特定区域，区域中便会生成相应的UI控件，此UI控件有自己的模板、行为等等。生成UI 后便会在区域
        中显示出来。所以我觉得将UI控件封为一个小组件，再动态加载，是个不错的方案。

        要实现这个功能，得先简单了解angular2 中相关的api,从@angular/core中导入:
            ViewChild：一个属性装饰器，用来从模板视图中获取对应的元素，可以通过模板变量获取，获取时可以通过 read 属性设置查询的条件，
            就是说可以把此视图转为不同的实例
            ViewContainerRef ：一个视图容器，可以在此上面创建、插入、删除组件等等
            ComponentFactoryResolve：一个服务，动态加载组件的核心，这个服务可以将一个组件实例呈现到另一个组件视图上
        有了这三个，一个简单的思路便连贯了：特定区域就是一个视图容器，可以通过 ViewChild 来实现获取和查询，然后使用
        ComponentFactoryResolve将已声明未实例化的组件解析成为可以动态加载的 component，再将此component 呈现到此前的视图容器中

        1.在父组件中我们使用
            constructor(private cfr : ComponentFactoryResolver) { }
            @ViewChild("target", { read : ViewContainerRef }) target : ViewContainerRef
            addcomponent(){
                let factory = this.cfr.resolveComponentFactory(oneComponent);  
                let component = this.target.createComponent(factory, 0);
            }
        2.在模块中声明该组件还得增加entryComponents:[onecomponent]

        3.如果你使用的是预编译的话就会有问题了，可以手动加入@angular/compiler包并做相应配置但是这就没意义了
        
            </pre>
            <div class="explain">
                angular2的变异过程大体可以分为三步就是Inputs(源代码)-----Parser(解析器)----->Instantiate(实例化),如果不是aot的话就是
                这三个过程全部浏览器去做，但是如果是aot的话就是服务器端通过compiler-cli来把它变成parser后的代码但是实例化(真正创建dom)
                还是在浏览器端实现
            </div>

            <div class="title">angular中asyncPipe中的用法</div>
            <pre>
        正常没用管道的情况下这样写：
            <textarea style="height: 650px;" readonly>
        <button (click)="newSeq()">New random sequence</button>
        <ul>
          <li [style.background-color]="item.color"
              *ngFor="let item of items">{{item.num}}</li>
        </ul>`

        export class AppComponent {
          ...
          subscription: Subscription;

          newSeq() {
            //每一次新的流出现都会创建一个订阅所以必须取消否则会有多个订阅事件发生
            if (this.subscription) {
              this.subscription.unsubscribe();
            }

            // generate a random color
            let color = '#' + Math.random().toString(16).slice(-6);

            this.subscription = Observable.interval(1000)
                  .scan((acc, num)=>[{num, color }, ...acc].slice(0, 5), [])
                  .subscribe(items => this.items = items);
          }
        }
        每次我们订阅一个Observable ，我们将它保存到组件实例的一个属性中。然后，当我们再次运
        行newSeq的时候，我们检查this.subscription是否存在，如果存在的话，我们就需要去调用
        unsubscribe来取消订阅。这就是为什么我们看不到我们的列表在各种颜色之间跳转，不管我
        们点击了按钮多少次,当然这里也可以使用switchMap来搞定
            </textarea> 

        当我们使用管道的时候就简单了:
            <textarea style="height: 550px;" readonly>
        <button (click)="newSeq()">New random sequence</button>
        <ul>
          <li [style.background-color]="item.color"
              *ngFor="let item of items | async">{{item.num}}</li>
        </ul>`
        export class AppComponent {
          items: Observable<any>;

          constructor () {
            this.newSeq();
          }

          newSeq() {

            // generate a random color
            let color = '#' + Math.random().toString(16).slice(-6);

            this.items = Observable.interval(1000)
                                   .scan((acc, num)=>[{num, color }, ...acc].slice(0, 5), []);
          }
        }
        AsyncPipe一旦组件被销毁，就会从Observables取消订阅。而且一旦表达式的引用发生变化，也会
        取消订阅，只要我们为此分配一个新的Observable，则AsyncPipe将自动取消订阅先前绑定的
        Observable！这不仅使我们的代码变得美观干净，还能保护我们免受非常微妙的内存泄漏
            </textarea>       
            </pre>
            <div class="explain">
                在变更检测方面，这意味着每次Observables 都可以检查所有组件。这是浪费资源。通过将组件的更改检测设置为OnPush，我们可以
                做得更好，这意味着如果输入（我们的案例中的数组）发生变化，它将只检查它的绑定
            </div>

        </div>
    </body>
</html>
