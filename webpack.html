<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Blog by limingkang</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <!-- <link rel="stylesheet" href="stylesheets/github-light.css"> -->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="前端开发记录">
    <meta name="keywords" content="gulp,react,node,webpack,redux,require,mysql,mongodb">
  </head>
  <body>
      <div class="big_container">
           <div class="title">webpack.config.js&emsp;<a href="http://webpack.github.io/docs/webpack-dev-server.html">官方配置地址</a></div>
           <pre>
        webpack命令：
            对于webpack命令来说。我们可以指定将某个文件翻译到某个位置如：webpack ./src/main.js ./build/build.js
            $ webpack --config XXX.js   //使用另一份配置文件（比如webpack.config2.js）来打包
            $ webpack --watch   //监听变动并自动打包
            $ webpack -p    //压缩混淆脚本，这个非常重要！
            $ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了


    	{
    	    entry: {
    	       page1: "./page1",
    	       page2: ["./entry1", "./entry2"]
    	    },
    	    output: {
    	       // 当使用多入口文件时候，要确保在output.filename使用[name]或者[id]
               filename: "[name].bundle.js",
    	       chunkFilename: "[id].bundle.js"，
               path: "/home/public/assets",
               publicPath: "/assets/"
    	    }
        }
        entry是页面中的入口文件：
           传入一个字符串，这个字符串就会被解析为启动时加载的模块。
           传入个数组["./entry1", "./entry2"]，所有模块都是启动时加载，模块导出到最后一个里面。
           传入一个对象，就会创建多个输入包文件，对象键的值就是chunk的name，值可以是字符串或者是数组。

        chunkFilename我的理解是未被列在entry中，却又需要被打包出来的文件命名配置。在按需加载（异步）模块的时候，这样的文件是
        没有被列在entry中的，如使用CommonJS的方式异步加载模块：
            require.ensure(["modules/tips.jsx"], function(require) {
                var a = require("modules/tips.jsx");
                // ...
            }, 'tips');
        异步加载的模块是要以文件形式加载，所以这时生成的文件名是以chunkname配置的，生成出的文件名就是tips.min.js

        path代表文件输出到的路径
        publicPath指定了一个在浏览器中被引用的URL地址,对于使用script和link加载器,当文件路径不同于他们的本地磁盘路径时候用
      


        let ExtractTextPlugin = require('extract-text-webpack-plugin');
        let extractCSS = new ExtractTextPlugin('stylesheets/[name].css');
        let extractLESS = new ExtractTextPlugin('stylesheets/[name].less');
        module.exports = {
              module: {
                loaders: [
                  {test: /\.scss$/i, loader: extractCSS.extract(['css','sass'])},
                  {test: /\.less$/i, loader: extractLESS.extract(['css','less'])},
                ]
              },
              plugins: [
                   //提公用js到common.js文件中
                   new webpack.optimize.CommonsChunkPlugin('common.js'),
                   //将样式统一发布到style.css中
                   new ExtractTextPlugin("style.css", {
                       allChunks: true,
                       disable: false
                   }),
                   //使用ProvidePlugin加载使用频率高的模块
                   new webpack.ProvidePlugin({
                       $: "webpack-zepto"
                   }),
                  extractCSS,
                  extractLESS
              ]
        };       
        plugins定义了需要使用的插件，如上包含两种：
    	    1、第一种webpack自带的一些插件：webpack.ProvidePlugin、webpack.optimize.CommonsChunkPlugin
    	    2、另外一种则通过npm包安装的：ExtractTextPlugin



        var webpack = require('webpack');
        var commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js');
        module.exports = {
            context 用于解析entry选项的基础目录(绝对路径), 如果output.pathinfo设置了，就包含了缩短过的目录；
            （相当于公共目录，下面所有的目录都在这个公共目录下面)
            context: __dirname + "/app",
            plugins: [commonsPlugin],         //如果加入这个参数页面引用的时候一定要先引用其生成的common.js否则报错
            entry: './src/main.js',
            output: {
               path: __dirname,
               filename: "./build/build.js",
            },
            module: {
                加载器配置
                loaders: [
                    { test: /\.css$/, loader: 'style-loader!css-loader' },
                    { test: /\.js$/, loader: 'jsx-loader?harmony', exclude: /node_modules/},
                    { test: /\.less$/, loader: 'style!css!less'},
                    //注意先得安装less，npm3.0以下的在安装less-loader的时候没有安装less
                    //注意less的解析时候配置顺序，是style!css!less，必须这个顺序，否则报错，从右到左解析的
                    { test: /\.(png|jpg)$/, loader: 'url-loader?limit=8192'}    
                    //url-loader 来说，它会将样式中引用到的图片转为模块来处理配置信息的参数“?limit=8192”表示将所有小于8kb的图片
                    //都转为base64形式（其实应该说超过8kb的才使用 url-loader 来映射到文件，否则转为data url形式）。也可以
                    //使用file-loader来加载资源文件
                ]
            },
            resolve定义了解析模块路径时的配置,常用的就是extensions;用来指定模块的后缀,这样引入模块时不需要写后缀,会自动补全
            resolve: {
                root: 'E:/github/flux-example/src', //绝对路径
                extensions: ['', '.js', '.json', '.scss'], //require时省略的扩展名,如:require('module')不需要module.js
                //别名
                alias: {
                    AppStore : 'js/stores/AppStores.js',
                    ActionType : 'js/actions/ActionType.js',
                    AppAction : 'js/actions/AppAction.js'
               }
            }
            打包后的文件有时候你是不容易找到出错了的地方对应的源代码的位置的，Source Maps为我们提供了一种对应编译文件和源文件的
            方法，在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包文件的构建速度
            devtool: '#source-map'
        };
           </pre>

           <div class="title">webpack-dev-server用法</div>
           <pre>
        1.webpack-dev-server有两种模式支持自动刷新——iframe模式和inline模式。在iframe模式下：页面是嵌套在一个iframe下的，在代码发生
        改动的时候，这个iframe会重新加载；在inline模式下：一个小型的webpack-dev-server客户端会作为入口文件打包，这个客户端会在后
        端代码改变的时候刷新页面。
        使用iframe模式无需额外的配置，只需在浏览器输入http://localhost:8080/webpack-dev-server/index.html
        使用inline模式有两种方式：命令行方式和Node.js API。
            1) 命令行方式比较简单，只需加入--line选项即可。例如：
            webpack-dev-server --inline
            使用--inline选项会自动把webpack-dev-server客户端加到webpack的入口文件配置中。
            webpack-dev-server命令会自动查找名为webpack.config.js的配置文件。如果你的配置文件名称不是webpack.config.js，
            需要在命令行中指明配置文件。例如webpack-dev-server --inline --config webpack.config.dev.js
            2) Node.js API方式需要手动把webpack-dev-server/client?http://localhost:8080加到配置文件的入口文件配置处，
            因为webpack-dev-server没有inline:true这个配置项
        
        2. webpac-dev-server支持Hot Module Replacement，即模块热替换，在前端代码变动的时候无需整个刷新页面，只把变化的部分替换掉。
        使用HMR功能也有两种方式：命令行方式和Node.js API。
        命令行方式同样比较简单，只需加入--line --hot选项。--hot这个选项干了一件事情，它把webpack/hot/dev-server入口点加入到了
        webpack配置文件中。这时访问浏览器，你会看见控制台的log信息：
            [HMR] Waiting for update signal from WDS...
            [WDS] Hot Module Replacement enabled.
            HMR前缀的信息由webpack/hot/dev-server模块产生，WDS前缀的信息由webpack-dev-server客户端产生。
        Node.js API方式需要做三个配置：
            1) 把webpack/hot/dev-server加入到webpack配置文件的entry项；
            2) 把new webpack.HotModuleReplacementPlugin()加入到webpack配置文件的plugins项；
            3) 把hot:true加入到webpack-dev-server的配置项里面。

        3.要将webpack-dev-server与后端服务器结合使用，需要做三件事情
            第一 首页HTML文件是从后端服务器发出的，这时页面的根地址变成了后端服务器地址，怎么使得webpack产生的资源文件在请求资源的
            时候是向web-dev-server请求而不是后端服务器请求？只需在webpack配置文件中的output.publicPath配置项写上绝对URL地址，
            例如output.publicPath = "http://localhost:8080/assets/"。这时，webpack打包产生的资源文件里面的url地址都会是绝对地址
            而不是相对地址。
            第二 后端服务器产生的入口HTML文件要向webpack-dev-server请求资源文件，这个简单，只需在HTML文件中加入资源文件的绝对地址，
            例如：<span><</span>script> src="http://localhost:8080/assets/bundle.js"><span><</span>/script>
            第三 要使webpack-dev-server和它的运行时程序连接起来。这个简单，只需要使用iline模式即可。
            例如：
                var compiler = Webpack(webpackConfig)
                var server = new WebpackDevServer(compiler, {
                    publicPath: config.publicPath,
                    stats: {
                        colors: true //显示不同的颜色区分打包的文件
                    },
                    proxy: { //代理服务器
                        '*': {
                            target: config.target,
                            changeOrigin: true
                        }
                    }
                })
                以上配置之后所有的请求都会是向代理的target服务器去请求处理上面的publicPath这个请求是向webpack-dev-server去发出的
           </pre>
           <div class="explain">
               webpack-dev-server是一个小型的node.js Express服务器,它使用webpack-dev-middleware中间件来为通过webpack打包生成的资
               源文件提供Web服务。它还有一个通过Socket.IO连接着webpack-dev-server服务器的小型运行时程序。webpack-dev-server发送关
               于编译状态的消息到客户端，客户端根据消息作出响应,实际运用可以去看github上的一个cnode-vue项目
           </div>          
      </div>
  </body>
</html>
